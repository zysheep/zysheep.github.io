<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java 8 新特性 | 三月三</title><meta name="description" content="Java 8 新特性Java8新增了非常多的特性，我们主要讨论以下几个：  Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。 方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 默认方法 − 默认方法就是一个在接口里面有了一个"><meta name="keywords" content="JavaSE,JDK1.8新特性"><meta name="author" content="三月三"><meta name="copyright" content="三月三"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="http://cdn.panyucable.cn/zysheep/ico.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="dns-prefetch" href="https://hm.baidu.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java 8 新特性"><meta name="twitter:description" content="Java 8 新特性Java8新增了非常多的特性，我们主要讨论以下几个：  Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。 方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 默认方法 − 默认方法就是一个在接口里面有了一个"><meta name="twitter:image" content="http://cdn.panyucable.cn/zysheep/2026x1136.jfif"><meta property="og:type" content="article"><meta property="og:title" content="Java 8 新特性"><meta property="og:url" content="https://zysheep.cn/2018/04/10/JavaSE/jdk1.8/40/"><meta property="og:site_name" content="三月三"><meta property="og:description" content="Java 8 新特性Java8新增了非常多的特性，我们主要讨论以下几个：  Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。 方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 默认方法 − 默认方法就是一个在接口里面有了一个"><meta property="og:image" content="http://cdn.panyucable.cn/zysheep/2026x1136.jfif"><meta property="article:published_time" content="2018-04-10T02:30:45.000Z"><meta property="article:modified_time" content="2020-05-23T03:05:59.668Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://zysheep.cn/2018/04/10/JavaSE/jdk1.8/40/"><link rel="prev" title="El表达式" href="https://zysheep.cn/2018/04/11/JavaEE/El%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><link rel="next" title="Java1.5-注解" href="https://zysheep.cn/2018/04/09/JavaSE/jdk1.5/41/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7f671f0f6d996680d21d5c32a23a9313";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://zysheep.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/hideCategory.min.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="http://cdn.panyucable.cn/zysheep/xiaoman.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">209</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">47</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">69</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-bug" aria-hidden="true"></i><span> 编程路线</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/java/"><i class="fa-fw fa fa-coffee"></i><span> Java</span></a></li><li><a class="site-page" href="/python/"><i class="fa-fw fa fa-binoculars"></i><span> Python</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-folder-open" aria-hidden="true"></i><span> 面试宝典</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/interview/"><i class="fa-fw fa fa-file-text-o"></i><span> Java面试题</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 我的生活</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-picture-o"></i><span> Gallery</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-8-新特性"><span class="toc-number">1.</span> <span class="toc-text">Java 8 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Lambda-表达式"><span class="toc-number">1.1.</span> <span class="toc-text">1. Lambda 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#语法"><span class="toc-number">1.1.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda-表达式实例"><span class="toc-number">1.1.2.</span> <span class="toc-text">Lambda 表达式实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda-表达式的结构"><span class="toc-number">1.1.3.</span> <span class="toc-text">Lambda 表达式的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简单应用"><span class="toc-number">1.1.4.</span> <span class="toc-text">简单应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-方法引用"><span class="toc-number">1.2.</span> <span class="toc-text">2. 方法引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-函数式接口"><span class="toc-number">2.</span> <span class="toc-text">3. 函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数式接口实例"><span class="toc-number">2.1.</span> <span class="toc-text">函数式接口实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Java-8-默认方法"><span class="toc-number">3.</span> <span class="toc-text">4. Java 8 默认方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#语法-1"><span class="toc-number">3.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多个默认方法"><span class="toc-number">3.2.</span> <span class="toc-text">多个默认方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态默认方法"><span class="toc-number">3.3.</span> <span class="toc-text">静态默认方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Java-8-Stream"><span class="toc-number">4.</span> <span class="toc-text">5. Java 8 Stream</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是-Stream？"><span class="toc-number">4.1.</span> <span class="toc-text">什么是 Stream？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生成流"><span class="toc-number">4.2.</span> <span class="toc-text">生成流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream-API"><span class="toc-number">4.2.1.</span> <span class="toc-text">Stream API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#中间操作"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">中间操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#filter-limit-shkip-distinct"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">filter(),limit(),shkip(),distinct()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">map()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sorted-sorted-Comparator-com"><span class="toc-number">4.2.1.4.</span> <span class="toc-text">sorted(),sorted(Comparator com)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#终止操作-终端操作"><span class="toc-number">4.2.2.</span> <span class="toc-text">终止操作(终端操作)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#reduce"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">reduce</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#collect"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">collect</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forEach"><span class="toc-number">4.2.3.</span> <span class="toc-text">forEach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-1"><span class="toc-number">4.2.4.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filter"><span class="toc-number">4.2.5.</span> <span class="toc-text">filter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#limit"><span class="toc-number">4.2.6.</span> <span class="toc-text">limit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sorted"><span class="toc-number">4.2.7.</span> <span class="toc-text">sorted</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并行（parallel）程序"><span class="toc-number">4.3.</span> <span class="toc-text">并行（parallel）程序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Optional类"><span class="toc-number">5.</span> <span class="toc-text">6. Optional类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Date-Time-API"><span class="toc-number">6.</span> <span class="toc-text">Date Time API</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(http://cdn.panyucable.cn/zysheep/2026x1136.jfif)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">三月三</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-bug" aria-hidden="true"></i><span> 编程路线</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/java/"><i class="fa-fw fa fa-coffee"></i><span> Java</span></a></li><li><a class="site-page" href="/python/"><i class="fa-fw fa fa-binoculars"></i><span> Python</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-folder-open" aria-hidden="true"></i><span> 面试宝典</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/interview/"><i class="fa-fw fa fa-file-text-o"></i><span> Java面试题</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 我的生活</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-picture-o"></i><span> Gallery</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Java 8 新特性</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2018-04-10 10:30:45"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2018-04-10</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-23 11:05:59"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-23</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JavaSE/">JavaSE</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JavaSE/Java%E9%AB%98%E7%BA%A7%E7%AF%87/">Java高级篇</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">7k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 30 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2018/04/10/JavaSE/jdk1.8/40/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Java-8-新特性"><a href="#Java-8-新特性" class="headerlink" title="Java 8 新特性"></a>Java 8 新特性</h1><p><code>Java8</code>新增了非常多的特性，我们主要讨论以下几个：</p>
<ul>
<li><strong>Lambda 表达式</strong> − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</li>
<li><strong>方法引用</strong> − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li>
<li><strong>默认方法</strong> − 默认方法就是一个在接口里面有了一个实现的方法。</li>
<li><strong>新工具</strong> − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</li>
<li><strong>Stream API</strong> −新添加的<code>Stream API（java.util.stream）</code> 把真正的函数式编程风格引入到Java中。</li>
<li><strong>Date Time API</strong> − 加强对日期与时间的处理。</li>
<li><strong>Optional 类</strong> − <code>Optional</code> 类已经成为 <code>Java 8</code> 类库的一部分，用来解决空指针异常。</li>
<li><strong>Nashorn, JavaScript 引擎</strong> − <code>Java 8</code>提供了一个新的<code>Nashorn javascript</code>引擎，它允许我们在<code>JVM</code>上运行特定的<code>javascript</code>应用。</li>
</ul>
<h2 id="1-Lambda-表达式"><a href="#1-Lambda-表达式" class="headerlink" title="1. Lambda 表达式"></a>1. Lambda 表达式</h2><p><code>Lambda</code> 表达式，也可称为闭包，它是推动 <code>Java 8</code>发布的最重要新特性。</p>
<p><code>Lambda</code>允许把函数作为一个方法的参数（函数作为参数传递进方法中）。使用 <code>Lambda</code>表达式可以使代码变的更加简洁紧凑。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>lambda</code>表达式的语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure>
<p>以下是lambda表达式的重要特征:</p>
<ul>
<li><strong>可选类型声明:</strong> 不需要声明参数类型，编译器可以统一识别参数值。</li>
<li><strong>可选的参数圆括号:</strong> 一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li><strong>可选的大括号:</strong> 如果主体包含了一个语句，就不需要使用大括号。</li>
<li><strong>可选的返回关键字:</strong> 如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li>
</ul>
<h3 id="Lambda-表达式实例"><a href="#Lambda-表达式实例" class="headerlink" title="Lambda 表达式实例"></a>Lambda 表达式实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 普通写法</span><br><span class="line">        PersonCallBack p&#x3D;new PersonCallBack() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void callback() &#123;</span><br><span class="line">                System.out.println(&quot;写作业!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new lamdabaTest3().test(&quot;小明&quot;,p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test(String name,PersonCallBack  callBack)&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        callBack.callback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数式接口</span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface PersonCallBack&#123;</span><br><span class="line">    void callback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然，这个并不是一个很简洁的写法，我们采用<code>Java8</code>的<code>Lambada</code>表达式来实现，那么如何简化呢？</p>
<p>整个过程：去掉修饰符(<code>public</code>等)、去掉函数的名字(因为已经赋给变量，变量知道此方法名–往后知道抽象方法唯一，不需要方法名了)、去掉返回值类型(编译器可以推断)、去掉参数类型(编译器可以推断参数类型)，最终的结果是下面的形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Lambada 写法</span><br><span class="line">PersonCallBack p1&#x3D; () -&gt; System.out.println(&quot;写作业!&quot;);</span><br><span class="line"></span><br><span class="line">new lamdabaTest3().test(&quot;小明&quot;,p);</span><br></pre></td></tr></table></figure>
<p><strong>分析:</strong> 这样的最终结果就是把”一块代码赋给一个变量”。或者说是”这个被赋给一个变量的函数”就是一个Lambada表达式，由于Lambada可以直接赋给一个”变量”，我们可以把Lambada(这里表示为变量)作为参数传递给函数。但是变量(Lambada表达式)的类型是什么呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数式接口</span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface PersonCallBack&#123;</span><br><span class="line">    void callback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：所有的Lambada的类型都是一个接口，而Lambada表达式本身(“那段代码”)就是一个接口的实现，这是理解<code>Lambada</code>的一个关键所在，理解上可以这样认为：<code>Lambada</code>表达式就是产生一个实现接口中唯一的抽象方法的子实现类的对象，因此最终结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Lambada 写法</span><br><span class="line">PersonCallBack p1&#x3D; () -&gt; System.out.println(&quot;写作业!&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>函数式接口:</strong> 接口中只有一个需要被实现的抽象函数</p>
<p>说明：为了避免后来的人在接口中增加新的接口函数，导致其有多个接口函数需要被实现，变成非函数式接口，引入了一个新的<code>Annotation</code>(注解)：<code>@FunctionalInterface</code>。可以把他它放在一个接口前，表示这个接口是一个函数式接口，加上它的接口不会被编译，如果加上此标记就不能再添加其他的抽象方法，否则会报错。它有点像<code>@Override</code>，都是声明了一种使用意图，避免你把它用错。</p>
<p><strong>总结:</strong> <code>lambda</code>表达式本质是匿名方法</p>
<h3 id="Lambda-表达式的结构"><a href="#Lambda-表达式的结构" class="headerlink" title="Lambda 表达式的结构"></a>Lambda 表达式的结构</h3><p>Lambada表达式的语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(param1,param2,param3) -&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>Lambda 表达式在Java 语言中引入了一个新的语法元素和操作符。这个操作符为 “ <code>-&gt;</code>”，该操作符被称为 <code>Lambda</code> 操作符或箭头操作符。它将 <code>Lambda</code> 分为两个部分：</p>
<ul>
<li>左侧:指定了 <code>Lambda</code> 表达式需要的方法参数列表</li>
<li>右侧:指定了 <code>Lambda</code> 体，即 <code>Lambda</code> 表达式要执行的功能</li>
</ul>
<p>使用说明:</p>
<ul>
<li>一个 Lambda 表达式可以有零个或多个参数，参数的类型既可以明确声明，也可以根据上下文来推断</li>
<li>圆括号内，方法参数列表之间用逗号相隔</li>
<li>当只有一个参数，且其类型可推导时，圆括号（）可省略</li>
<li><code>Lambda</code> 表达式的主体可包含零条或多条语句，如果<code>Lambda</code>表达式的主体只有一条语句，花括号<code>{}</code>可省略，如果有返回值，<code>return</code>也可以省略，同时<code>body</code>中的“;”也可以省略。匿名函数的返回类型与该主体表达式一致</li>
<li>如果 <code>Lambda</code> 表达式的主体包含一条以上语句，则表达式必须包含在花括号<code>{}</code>中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li>
</ul>
<h3 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h3><p>对比匿名内部类做为参数传递和<code>Lambda</code>表达式作为参数来传递–Runnable,Callable接口(具体看例子)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class LamadaDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;匿名内部类的形式开启一个线程</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;我爱你！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;Lambada表达式创建匿名内部类开启一个线程</span><br><span class="line">        new Thread(() -&gt; System.out.println(&quot;-------------&quot;)).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class LamadaDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;常见的函数式接口：Runnable、 Comparable--排序(是一个函数式接口吗？)</span><br><span class="line"> </span><br><span class="line">         Comparable&lt;Integer&gt; comparable&#x3D;new Comparable&lt;Integer&gt;() &#123;</span><br><span class="line">             @Override</span><br><span class="line">             public int compareTo(Integer o) &#123;</span><br><span class="line">                 return 0;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;;</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F;Lambada表达式的方法</span><br><span class="line"> </span><br><span class="line">        Comparable&lt;Integer&gt; com&#x3D;(a)-&gt;a;</span><br><span class="line">        int i &#x3D; com.compareTo(3);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-方法引用"><a href="#2-方法引用" class="headerlink" title="2. 方法引用"></a>2. 方法引用</h2><p>概念: 方法引用其实是<code>Lambda</code>表达式的另一种写法,当要传递给<code>Lambda</code>体的操作已经有实现的方法了，可以使用方法引用</p>
<p>语法：使用操作符 “ <code>::</code>” 将方法名和对象或类的名字分隔开来</p>
<p>几种常见形式：</p>
<ul>
<li>类名::静态方法</li>
<li>对象::实例方法</li>
<li>类名::实例方法</li>
</ul>
<p>二.构造器引用</p>
<ul>
<li>ClassName::new</li>
</ul>
<p>三 数组引用</p>
<ul>
<li>Type::new</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>Lambda体中调用方法的参数列表与返回值类型，要与函数式接口中抽象方法的函数列表和返回值类型保存一致</li>
<li>若Lambda参数列表中的第一个参数是实例方法的调用者，而第二个参数是实例方法的参数时，可以使用ClassName::method；不管怎么说，实质还是抽象方法的实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;** 一.方法引用:若Lambda体中的内容有方法已经实现了,我们可以使用&quot;方法引用&quot;</span><br><span class="line"> *          (可以理解为方法引用是Lambda表达式的另外一种表现形式)</span><br><span class="line"> *</span><br><span class="line"> *  主要有三种语法格式:</span><br><span class="line"> *    对象::实例方法</span><br><span class="line"> *    类::静态方法名</span><br><span class="line"> *    类::实例方法名</span><br><span class="line"> * 注意:</span><br><span class="line"> *  1.Lambda 体中调用方法的参数列表与返回值类型,要与函数式接口中抽象方法的函数列表和返回值类型保持一致!</span><br><span class="line"> *  2.若Lambda参数列表中的第一个参数是实例方法的调用者,而第二个参数是实例方法的参数时,可以使用ClassName::method</span><br><span class="line"> * 二.构造器引用</span><br><span class="line"> *</span><br><span class="line"> * ClassName::new</span><br><span class="line"> *</span><br><span class="line"> * 三 数组引用</span><br><span class="line"> *</span><br><span class="line"> * Type::new</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public class TestMethodRef &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;数组引用</span><br><span class="line">    @Test</span><br><span class="line">    public void test7()&#123;</span><br><span class="line">        Function&lt;Integer,String[]&gt; function &#x3D; (x) -&gt; new String[x];</span><br><span class="line">        String[] strings &#x3D; function.apply(10);</span><br><span class="line">        System.out.println(strings);</span><br><span class="line"></span><br><span class="line">        Function&lt;Integer,String[]&gt; function2 &#x3D; String[]::new;</span><br><span class="line">        System.out.println(function2.apply(10).length);</span><br><span class="line"></span><br><span class="line">        Supplier&lt;ArrayList&lt;Person&gt;&gt; supplier &#x3D; () -&gt; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Supplier&lt;ArrayList&lt;Person&gt;&gt; supplier1 &#x3D; ArrayList::new;</span><br><span class="line">        ArrayList&lt;Person&gt; people &#x3D; supplier1.get();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;构造器引用</span><br><span class="line">    @Test</span><br><span class="line">    public void test5()&#123;</span><br><span class="line">        Supplier&lt;Person&gt; supplier &#x3D; () -&gt; new Person();</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Person&gt; supplier1 &#x3D; Person::new;</span><br><span class="line">        System.out.println(supplier1.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test6()&#123;</span><br><span class="line">        Function&lt;Integer,Person&gt; function &#x3D; (x) -&gt; new Person(x);</span><br><span class="line"></span><br><span class="line">        Function&lt;Integer,Person&gt; function1 &#x3D; Person::new;</span><br><span class="line"></span><br><span class="line">        Person apply &#x3D; function1.apply(15);</span><br><span class="line">        System.out.println(apply);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;对象::实例方法</span><br><span class="line">    @Test</span><br><span class="line">    public void  test1()&#123;</span><br><span class="line">        Consumer&lt;String&gt; con &#x3D; (x) -&gt; System.out.println(x);</span><br><span class="line"></span><br><span class="line">        PrintStream out &#x3D; System.out;</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; con1 &#x3D; out::println;</span><br><span class="line"></span><br><span class="line">        con1.accept(&quot;asdfs&quot;);</span><br><span class="line"></span><br><span class="line">        BiFunction&lt;String,Integer,Person&gt; biFunction &#x3D; (x,y) -&gt; new Person(x,y);</span><br><span class="line"></span><br><span class="line">        BiFunction&lt;String,Integer,Person&gt; biFunction1 &#x3D; Person::new;</span><br><span class="line">        System.out.println(biFunction1.apply(&quot;小名&quot;,19));</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void test2() &#123;</span><br><span class="line">        Person person &#x3D; new Person();</span><br><span class="line"></span><br><span class="line">        Supplier&lt;String&gt; supplier &#x3D;  () -&gt; person.getUserName();</span><br><span class="line"></span><br><span class="line">        String s &#x3D; supplier.get();</span><br><span class="line">        &#x2F;&#x2F;对象::实例方法</span><br><span class="line">        Supplier&lt;Integer&gt; supplier1 &#x3D; person::getAge;</span><br><span class="line"></span><br><span class="line">        System.out.println(supplier1.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;类::静态方法名</span><br><span class="line">    @Test</span><br><span class="line">    public void test3()&#123;</span><br><span class="line">        Comparator&lt;Integer&gt; com &#x3D; (x,y) -&gt; Integer.compare(x,y);</span><br><span class="line"></span><br><span class="line">        Comparator&lt;Integer&gt; com1 &#x3D; Integer::compare;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;类::实例方法名</span><br><span class="line">    @Test</span><br><span class="line">    public void test4()&#123;</span><br><span class="line">        BiPredicate&lt;String,String&gt; bp &#x3D; (x,y) -&gt; x.equals(y);</span><br><span class="line"></span><br><span class="line">        BiPredicate&lt;String,String&gt; bp1 &#x3D; String::equals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="3-函数式接口"><a href="#3-函数式接口" class="headerlink" title="3. 函数式接口"></a>3. 函数式接口</h1><p>函数式接口(<code>Functional Interface</code>)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。在接口上添加<code>@FunctionalInterface</code>注解声明为函数时接口</p>
<p>函数式接口可以被隐式转换为 <code>lambda</code> 表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface MathOperation &#123;</span><br><span class="line">    Integer add(Integer a,Integer b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数式接口可以对现有的函数友好地支持 <code>lambda</code>。</p>
<p><code>JDK 1.8</code> 新增加的函数接口：</p>
<ul>
<li><code>java.util.function</code></li>
</ul>
<p><code>java.util.function</code> 它包含了很多类，用来支持 <code>Java</code>的 函数式编程，该包中的函数式接口有：<br>序号|    接口 &amp; 描述<br>—|—<br>1|Function&lt;T,R&gt;  method:  R apply(T t);</p>
<ul>
<li>|接受一个输入参数，返回一个结果。<br>2|Consumer<T>  method:   void accept(T t);</li>
<li>|代表了接受一个输入参数并且无返回的操作<br>3|Predicate<T>  method: boolean test(T t);</li>
<li>|接受一个输入参数，返回一个布尔值结果。<br>4|Supplier<T>  method :  T get();</li>
<li>|无参数，返回一个结果。</li>
</ul>
<h2 id="函数式接口实例"><a href="#函数式接口实例" class="headerlink" title="函数式接口实例"></a>函数式接口实例</h2><p><code>Predicate &lt;T&gt;</code> 接口是一个函数式接口，它接受一个输入参数 T，返回一个布尔值结果。</p>
<p>该接口包含多种默认方法来将<code>Predicate</code>组合成其他复杂的逻辑（比如：与，或，非）。</p>
<p>该接口用于测试对象是 true 或 false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    Java 8 内置的四大核心函数式接口</span><br><span class="line"></span><br><span class="line">    Consumer&lt;T&gt; :消费型接口</span><br><span class="line">         void accept(T t);</span><br><span class="line">    Supplier&lt;T&gt; : 供给型接口</span><br><span class="line">           T get();</span><br><span class="line">    Function&lt;T,R&gt; :函数式接口</span><br><span class="line">            R apply(T t);</span><br><span class="line">    Predicate&lt;T&gt; :断言型接口</span><br><span class="line">            boolean test(T t);</span><br><span class="line"></span><br><span class="line"> *&#x2F;</span><br><span class="line">public class LambdaDemo6 &#123;</span><br><span class="line">    &#x2F;&#x2F;  Consumer&lt;T&gt; :消费型接口</span><br><span class="line">    @Test</span><br><span class="line">    public void test1()&#123;</span><br><span class="line">        happy(1000,(m)-&gt; System.out.println(&quot;洗澡消费&quot;+m+&quot;元&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    public void happy(double money, Consumer&lt;Double&gt; con)&#123;</span><br><span class="line">        con.accept(money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Supplier&lt;T&gt; : 供给型接口</span><br><span class="line">    @Test</span><br><span class="line">    public void test2()&#123;</span><br><span class="line">        getNumList(10,() -&gt; (int)( Math.random()*100)).forEach((m)-&gt; System.out.println(m));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;产生指定个数的整数,并放入集合中</span><br><span class="line">    public List&lt;Integer&gt; getNumList(int num, Supplier&lt;Integer&gt; supplier)&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i&#x3D;0;i&lt;num;i++)&#123;</span><br><span class="line">            Integer integer &#x3D; supplier.get();</span><br><span class="line">            list.add(integer);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Function&lt;T,R&gt; :函数式接口</span><br><span class="line">    @Test</span><br><span class="line">    public void test3()&#123;</span><br><span class="line">        String newStr &#x3D; strHandler(&quot;\t\t\t\t 我爱张柏芝&quot;,(a)-&gt; a.trim());</span><br><span class="line">        System.out.println(newStr);</span><br><span class="line"></span><br><span class="line">        String subStr &#x3D; strHandler(&quot;我喜欢你&quot;,(a)-&gt;a.substring(0,3));</span><br><span class="line">        System.out.println(subStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;需求:用于处理字符串</span><br><span class="line">    public String strHandler(String str, Function&lt;String,String&gt; function)&#123;</span><br><span class="line">        return function.apply(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Predicate&lt;T&gt; :断言型接口</span><br><span class="line">    @Test</span><br><span class="line">    public void test4()&#123;</span><br><span class="line">        List&lt;String&gt; lists &#x3D; Arrays.asList(&quot;Hello&quot;,&quot;atagui&quot;,&quot;Lambda&quot;,&quot;www&quot;,&quot;ok&quot;);</span><br><span class="line">        filterStr(lists,(s) -&gt; s.length()&gt;3).forEach((a)-&gt; System.out.println(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将满足条件的字符串放入到集合中</span><br><span class="line">    public List&lt;String&gt; filterStr(List&lt;String&gt; list,Predicate&lt;String&gt; predicate) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; strList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (String str : list) &#123;</span><br><span class="line">            if (predicate.test(str))&#123;</span><br><span class="line">                strList.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return strList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-Java-8-默认方法"><a href="#4-Java-8-默认方法" class="headerlink" title="4. Java 8 默认方法"></a>4. Java 8 默认方法</h1><p><code>Java 8</code>新增了接口的默认方法。简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。</p>
<blockquote>
<p>为什么要有这个特性？</p>
</blockquote>
<p><strong>首先</strong>，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的 <code>java 8</code> 之前的集合框架没有 <code>foreach</code>方法，通常能想到的解决办法是在<code>JDK</code>里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。</p>
<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Vehicle &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多个默认方法"><a href="#多个默认方法" class="headerlink" title="多个默认方法"></a>多个默认方法</h2><p>一个接口有默认方法，考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法，以下实例说明了这种情况的解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface Vehicle &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public interface FourWheeler &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆四轮车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个解决方案是创建自己的默认方法，来覆盖重写接口的默认方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Vehicle, FourWheeler &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆四轮汽车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种解决方案可以使用 super 来调用指定接口的默认方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Vehicle, FourWheeler &#123;</span><br><span class="line">   public void print()&#123;</span><br><span class="line">      Vehicle.super.print();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态默认方法"><a href="#静态默认方法" class="headerlink" title="静态默认方法"></a>静态默认方法</h2><p><code>Java 8</code> 的另一个特性是接口可以声明（并且可以提供实现）静态方法。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Vehicle &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F; 静态方法</span><br><span class="line">   static void blowHorn()&#123;</span><br><span class="line">      System.out.println(&quot;按喇叭!!!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-Java-8-Stream"><a href="#5-Java-8-Stream" class="headerlink" title="5. Java 8 Stream"></a>5. Java 8 Stream</h1><p><code>Java 8 API</code>添加了一个新的抽象称为流<code>Stream</code>，可以让你以一种声明的方式处理数据。</p>
<p><code>Stream</code>使用一种类似用 <code>SQL</code> 语句从数据库查询数据的直观方式来提供一种对<code>Java</code>集合运算和表达的高阶抽象。</p>
<p><code>Stream API</code>可以极大提高<code>Java</code>程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p>
<p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如<strong>筛选</strong>，<strong>排序</strong>，<strong>聚合</strong>等。</p>
<p>元素流在管道中经过中间操作（<code>intermediate operation</code>）的处理，最后由最终操作(<code>terminal operation</code>)得到前面处理的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br><span class="line">| stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|</span><br><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br></pre></td></tr></table></figure>

<h2 id="什么是-Stream？"><a href="#什么是-Stream？" class="headerlink" title="什么是 Stream？"></a>什么是 Stream？</h2><p><code>Stream</code>（流）是一个来自数据源的元素队列并支持聚合操作</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。 <code>Java</code>中的<code>Stream</code>并不会存储元素，而是按需计算。</li>
<li><strong>数据源</strong> 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li>
<li><strong>聚合操作</strong> 类似<code>SQL</code>语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li>
</ul>
<p>和以前的<code>Collection</code>操作不同， <code>Stream</code>操作还有两个基础的特征：</p>
<ul>
<li><strong>Pipelining:</strong> 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>
<li><strong>内部迭代：</strong> 以前对集合遍历都是通过<code>Iterator</code>或者<code>For-Each</code>的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 <code>Stream</code>提供了内部迭代的方式， 通过访问者模式(<code>Visitor</code>实现。</li>
</ul>
<h2 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h2><p>在<code>Java 8</code>中, 集合接口有两个方法来生成流：</p>
<ul>
<li><strong>stream()</strong> − 为集合创建串行流。</li>
<li><strong>parallelStream()</strong> − 为集合创建并行流。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 一 Stream的三个步骤</span><br><span class="line"> * 1. 创建Stream流</span><br><span class="line"> * 2. 中间操作</span><br><span class="line"> * 3. 终止操作(终端操作)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TestStreamAPI &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建Stream</span><br><span class="line">    @Test</span><br><span class="line">    public void test1()&#123;</span><br><span class="line">        &#x2F;&#x2F;1. 可以通过Collection系列集合提供的stream() 或 parallelSteam()</span><br><span class="line">        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; stream &#x3D; list.stream();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;2.通过Arrays中的静态方法stream()获取数组流</span><br><span class="line">        Person[] persion &#x3D; new Person[10];</span><br><span class="line">        Stream&lt;Person&gt; stream1 &#x3D; Arrays.stream(persion);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;3. 通过Stream类中的静态方法of()</span><br><span class="line">        Stream&lt;String&gt; aaa &#x3D; Stream.of(&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;4. 创建无限流</span><br><span class="line">        &#x2F;&#x2F;迭代</span><br><span class="line">        Stream&lt;Integer&gt; iterate &#x3D; Stream.iterate(1, (x) -&gt; x + 3);</span><br><span class="line">        iterate.limit(10).forEach((x)-&gt; System.out.println(x));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;生成</span><br><span class="line">        Stream.generate(()-&gt;(int)(Math.random()*100)).limit(10).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h3><h4 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h4><h4 id="filter-limit-shkip-distinct"><a href="#filter-limit-shkip-distinct" class="headerlink" title="filter(),limit(),shkip(),distinct()"></a>filter(),limit(),shkip(),distinct()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 筛选与切片</span><br><span class="line"> *</span><br><span class="line"> * filter---接收Lambda,从流中排除某些元素</span><br><span class="line"> * limit()---截断流,使其不超过给定数量</span><br><span class="line"> * skip()---跳过元素,返回一个扔掉了前n个元素的流,若流中元素不足n个,则返回一个空流,与limit(n)互补</span><br><span class="line"> * distinct--筛选,通过流所生成元素的hashcode()和equals()去除重复元素</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test3()&#123;</span><br><span class="line">    list.stream()</span><br><span class="line">            .filter((x)-&gt;x.getAge()&gt;20)</span><br><span class="line">            .skip(2)</span><br><span class="line">            .distinct()</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">    list.stream()</span><br><span class="line">            .filter((e)-&gt; &#123;</span><br><span class="line">                System.out.println(&quot;短路&quot;);</span><br><span class="line">               return e.getAge()&gt;20;</span><br><span class="line">            &#125;)</span><br><span class="line">            .limit(2)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;内部迭代:迭代操作有Stream API完成</span><br><span class="line">@Test</span><br><span class="line">public void test1()&#123;</span><br><span class="line">    &#x2F;&#x2F;中间操作</span><br><span class="line">    Stream&lt;Person&gt; personStream &#x3D; list.stream()</span><br><span class="line">            .filter((e) -&gt; &#123;</span><br><span class="line">                System.out.println(&quot;Stream API的中间操作&quot;);</span><br><span class="line">               return e.getAge() &gt; 22;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;终止操作:一次性执行全部内容,即&quot;惰性求值&quot;</span><br><span class="line">    personStream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 映射</span><br><span class="line"> * map---接收Lambda,将元素转换成其他形式或提取信息,接收一个函数作为参数,该函数会被应用到每个元素上,并将其映射成一个新的元素</span><br><span class="line"> *flatMap--- 接收一个函数作为参数,将流中的每个值都换成另一个流,然后把所有流连接成一个流</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void test4()&#123;</span><br><span class="line">    List&lt;String&gt; lists &#x3D; Arrays.asList(&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;,&quot;eee&quot;);</span><br><span class="line">    lists.stream()</span><br><span class="line">            .map((x)-&gt; x.toUpperCase())</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">    System.out.println(&quot;----------------------&quot;);</span><br><span class="line"></span><br><span class="line">    list.stream()</span><br><span class="line">            .map(Person::getUserName)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">    System.out.println(&quot;-----------------------&quot;);</span><br><span class="line"></span><br><span class="line">    Stream&lt;Stream&lt;Character&gt;&gt; stream &#x3D; lists.stream()</span><br><span class="line">            .map((x) -&gt; TestStreamAPI2.filterCharacter(x));</span><br><span class="line">    stream.forEach((sm)-&gt;</span><br><span class="line">            sm.forEach(System.out::println)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;-----------------------&quot;);</span><br><span class="line">    &#x2F;&#x2F;flatMap</span><br><span class="line">    Stream&lt;Character&gt; characterStream &#x3D; lists.stream()</span><br><span class="line">            .flatMap(TestStreamAPI2::filterCharacter);</span><br><span class="line">    characterStream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static  Stream&lt;Character&gt; filterCharacter(String str)&#123;</span><br><span class="line">    List&lt;Character&gt; list1 &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (Character ch:str.toCharArray()) &#123;</span><br><span class="line">        list1.add(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    return  list1.stream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sorted-sorted-Comparator-com"><a href="#sorted-sorted-Comparator-com" class="headerlink" title="sorted(),sorted(Comparator com)"></a>sorted(),sorted(Comparator com)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 排序</span><br><span class="line"> * sorted()---自然排序 (Comparable)</span><br><span class="line"> * sorted(Comparator com) ---定制排序(Comparator)</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"> @Test</span><br><span class="line"> public void test6()&#123;</span><br><span class="line">     List&lt;String&gt; lists &#x3D; Arrays.asList(&quot;bbb&quot;,&quot;aaa&quot;,&quot;ddd&quot;,&quot;eee&quot;,&quot;ccc&quot;);</span><br><span class="line">     lists.stream()</span><br><span class="line">             .sorted()</span><br><span class="line">             .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">     System.out.println(&quot;------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">     list.stream()</span><br><span class="line">             .sorted((e1,e2)-&gt; e1.getAge().compareTo(e2.getAge())).forEach(System.out::println);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="终止操作-终端操作"><a href="#终止操作-终端操作" class="headerlink" title="终止操作(终端操作)"></a>终止操作(终端操作)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 查找与匹配</span><br><span class="line"> * allMatch---检查是否匹配所有元素</span><br><span class="line"> * anyMatch---检查是否至少匹配一个元素</span><br><span class="line"> * noneMatch---检查是否没有匹配所有元素</span><br><span class="line"> * findFirst---返回第一个元素</span><br><span class="line"> * findAny---返回当前流中的任意元素</span><br><span class="line"> * count---放回流中元素的总个数</span><br><span class="line"> * max---返回流中最大值</span><br><span class="line"> * min---返回流中最小值</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public  void test2()&#123;</span><br><span class="line">    long count &#x3D; list.stream()</span><br><span class="line">            .count();</span><br><span class="line">    System.out.println(count);</span><br><span class="line"></span><br><span class="line">    Optional&lt;Person&gt; max &#x3D; list.stream()</span><br><span class="line">            .max((e1, e2) -&gt; Integer.compare(e1.getAge(), e2.getAge()));</span><br><span class="line">    System.out.println(max.get());</span><br><span class="line"></span><br><span class="line">    Optional&lt;Integer&gt; min &#x3D; list.stream()</span><br><span class="line">            .map(Person::getAge)</span><br><span class="line">            .min(Integer::compareTo);</span><br><span class="line">    System.out.println(min.get());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test1()&#123;</span><br><span class="line">    boolean b &#x3D; list.stream()</span><br><span class="line">            .allMatch((e) -&gt; e.getStatus().equals(Status.BUSY));</span><br><span class="line">    System.out.println(b);</span><br><span class="line"></span><br><span class="line">    boolean b1 &#x3D; list.stream()</span><br><span class="line">            .anyMatch((e) -&gt; e.getStatus().equals(Status.BUSY));</span><br><span class="line">    System.out.println(b1);</span><br><span class="line"></span><br><span class="line">    boolean b2 &#x3D; list.stream()</span><br><span class="line">            .noneMatch((e) -&gt; e.getStatus().equals(Status.BUSY));</span><br><span class="line">    System.out.println(b2);</span><br><span class="line"></span><br><span class="line">    Optional&lt;Person&gt; op &#x3D; list.stream()</span><br><span class="line">            .sorted((e1, e2) -&gt; -Integer.compare(e1.getAge(), e2.getAge()))</span><br><span class="line">            .findFirst();</span><br><span class="line">    &#x2F;&#x2F;System.out.println(op.get());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;多线程查找</span><br><span class="line">    Optional&lt;Person&gt; op1 &#x3D; list.parallelStream()</span><br><span class="line">            .filter((e) -&gt; e.getStatus().equals(Status.FREE))</span><br><span class="line">            .findAny();</span><br><span class="line">    System.out.println(op1.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**归约:</span><br><span class="line"> * reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</span><br><span class="line"> * reduce(BinaryOperator&lt;T&gt; accumulator)</span><br><span class="line"> * 可以将流中元素反复结合起来,得到一个值</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">  @Test</span><br><span class="line">  public void test3()&#123;</span><br><span class="line">      List&lt;Integer&gt; list1 &#x3D; Arrays.asList(1,2,3,4,5,6,7,8,9,10);</span><br><span class="line">      Integer sum &#x3D; list1.stream()</span><br><span class="line">              .reduce(0, (x, y) -&gt; x + y);</span><br><span class="line">      System.out.println(sum);</span><br><span class="line">      System.out.println(&quot;---------------------&quot;);</span><br><span class="line"></span><br><span class="line">      Optional&lt;Integer&gt; reduce &#x3D; list.stream()</span><br><span class="line">              .map(Person::getAge)</span><br><span class="line">              .reduce(Integer::sum);</span><br><span class="line">      System.out.println(reduce.get());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">  * 收集</span><br><span class="line">  * collect---将流转换为其他形式,接收一个Collector接口的实现,用于给Stream中元素做汇总的方法</span><br><span class="line">  *&#x2F;</span><br><span class="line"> @Test</span><br><span class="line"> public void test5()&#123;</span><br><span class="line">     &#x2F;&#x2F;总数</span><br><span class="line">     Long collect &#x3D; list.stream()</span><br><span class="line">             .collect(Collectors.counting());</span><br><span class="line">     System.out.println(&quot;总数:&quot;+collect);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;平均值</span><br><span class="line">     Double collect1 &#x3D; list.stream()</span><br><span class="line">             .collect(Collectors.averagingLong(Person::getAge));</span><br><span class="line"></span><br><span class="line">     System.out.println(&quot;平均值:&quot;+collect1);</span><br><span class="line">     &#x2F;&#x2F;总和</span><br><span class="line">     Integer collect2 &#x3D; list.stream()</span><br><span class="line">             .collect(Collectors.summingInt(Person::getAge));</span><br><span class="line">     System.out.println(&quot;总和:&quot;+collect2);</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;最大值</span><br><span class="line">     Optional&lt;Person&gt; collect3 &#x3D; list.stream()</span><br><span class="line">             .collect(Collectors.maxBy((e1, e2) -&gt; Integer.compare(e1.getAge(), e2.getAge())));</span><br><span class="line">     System.out.println(&quot;最大值:&quot;+collect3.get());</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;最小值</span><br><span class="line">     Optional&lt;Person&gt; collect4 &#x3D; list.stream()</span><br><span class="line">             .collect(Collectors.minBy((e1, e2) -&gt; Integer.compare(e1.getAge(), e2.getAge())));</span><br><span class="line">     System.out.println(&quot;最小值:&quot;+collect4.get());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> @Test</span><br><span class="line"> public void test4()&#123;</span><br><span class="line">     List&lt;String&gt; collect &#x3D; list.stream()</span><br><span class="line">             .map(Person::getUserName)</span><br><span class="line">             .collect(Collectors.toList());</span><br><span class="line">     &#x2F;&#x2F;collect.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">     Set&lt;String&gt; collect1 &#x3D; list.stream()</span><br><span class="line">             .map(Person::getUserName)</span><br><span class="line">             .collect(Collectors.toSet());</span><br><span class="line">     collect1.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">     Set&lt;String&gt; collect2 &#x3D; list.stream()</span><br><span class="line">             .map(Person::getUserName)</span><br><span class="line">             .collect(Collectors.toCollection(HashSet::new));</span><br><span class="line"> &#125;</span><br><span class="line">&#x2F;&#x2F;分组</span><br><span class="line"> @Test</span><br><span class="line"> public void test6()&#123;</span><br><span class="line">     Map&lt;Status, List&lt;Person&gt;&gt; map &#x3D; list.stream()</span><br><span class="line">             .collect(Collectors.groupingBy(Person::getStatus));</span><br><span class="line">     System.out.println(map);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;多级分组</span><br><span class="line"> @Test</span><br><span class="line"> public void test7()&#123;</span><br><span class="line">     Map&lt;Status, Map&lt;String, List&lt;Person&gt;&gt;&gt; collect &#x3D; list.stream()</span><br><span class="line">             .collect(Collectors.groupingBy(Person::getStatus, Collectors.groupingBy(</span><br><span class="line">                     (e) -&gt; &#123;</span><br><span class="line">                         if (((Person) e).getAge() &lt; 20) &#123;</span><br><span class="line">                             return &quot;高中生&quot;;</span><br><span class="line">                         &#125; else if (((Person) e).getAge() &gt; 20) &#123;</span><br><span class="line">                             return &quot;大学生&quot;;</span><br><span class="line">                         &#125; else &#123;</span><br><span class="line">                             return &quot;成年人&quot;;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">             )));</span><br><span class="line">     System.out.println(collect);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;分区  满足条件一个区,不满足条件一个区</span><br><span class="line"> @Test</span><br><span class="line"> public void test8()&#123;</span><br><span class="line">     Map&lt;Boolean, List&lt;Person&gt;&gt; collect &#x3D; list.stream()</span><br><span class="line">             .collect(Collectors.partitioningBy((e) -&gt; e.getAge() &gt; 22));</span><br><span class="line">     System.out.println(collect);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">     @Test</span><br><span class="line"> public void test10()&#123;</span><br><span class="line">     String collect &#x3D; list.stream()</span><br><span class="line">             .map(Person::getUserName)</span><br><span class="line">             .collect(Collectors.joining(&quot;,&quot;,&quot;&#x3D;&#x3D;&#x3D;&quot;,&quot;&#x3D;&#x3D;&#x3D;&quot;));</span><br><span class="line">     System.out.println(collect);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> @Test</span><br><span class="line"> public void test9()&#123;</span><br><span class="line">     IntSummaryStatistics collect &#x3D; list.stream()</span><br><span class="line">             .collect(Collectors.summarizingInt(Person::getAge));</span><br><span class="line"></span><br><span class="line">     System.out.println(collect.getMax());</span><br><span class="line">     System.out.println(collect.getSum());</span><br><span class="line">     System.out.println(collect.getMin());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><code>Stream</code> 提供了新的方法<code>&#39;forEach&#39;</code>来迭代流中的每个数据。以下代码片段使用<code>forEach</code> 输出了10个随机数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random &#x3D; new Random();</span><br><span class="line">random.ints().limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="map-1"><a href="#map-1" class="headerlink" title="map"></a>map</h3><p><code>map</code>方法用于映射每个元素到对应的结果，以下代码片段使用 <code>map</code> 输出了元素对应的平方数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers &#x3D; Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">&#x2F;&#x2F; 获取对应的平方数</span><br><span class="line">List&lt;Integer&gt; squaresList &#x3D; numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><code>filter</code> 方法用于通过设置的条件过滤出元素。以下代码片段使用 <code>filter</code> 方法过滤出空字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings &#x3D; Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">&#x2F;&#x2F; 获取空字符串的数量</span><br><span class="line">long count &#x3D; strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure>
<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p><code>limit</code> 方法用于获取指定数量的流。 以下代码片段使用 <code>limit</code>方法打印出 10 条数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random &#x3D; new Random();</span><br><span class="line">random.ints().limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p><code>sorted</code>方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random &#x3D; new Random();</span><br><span class="line">random.ints().limit(10).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h2 id="并行（parallel）程序"><a href="#并行（parallel）程序" class="headerlink" title="并行（parallel）程序"></a>并行（parallel）程序</h2><p><code>parallelStream</code> 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings &#x3D; Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">&#x2F;&#x2F; 获取空字符串的数量</span><br><span class="line">int count &#x3D; strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure>

<h1 id="6-Optional类"><a href="#6-Optional类" class="headerlink" title="6. Optional类"></a>6. Optional类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class TestOptional &#123;</span><br><span class="line">    &#x2F;&#x2F;用于解决空指针异常</span><br><span class="line">    &#x2F;&#x2F;Optional 容器类的常用方法</span><br><span class="line">    &#x2F;**Optional.of(T t) :创建一个optional实例</span><br><span class="line">     * Optional.empty() : 创建一个空的Optional实例</span><br><span class="line">     * Optional.ofNullable(T t):若t不为null,创建Optional实例,否则创建空实例</span><br><span class="line">     * isPresent(T t) : 判断是否包含值</span><br><span class="line">     * orElse(T t) : 如果调用对象包含值,返回该值,否则返回t</span><br><span class="line">     * orElseGet(Supplier s) : 如果调用对象包含值,返回该值,否则返回s获取的值</span><br><span class="line">     * map(Function f) : 如果有值对其处理,并返回处理后的Optional,否则返回Optional.empty()</span><br><span class="line">     * flatMap(Function mapper) : 与map类似,要求返回值必须是Optional</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test5()&#123;</span><br><span class="line">        Optional&lt;Person&gt; optionalPerson &#x3D; Optional.ofNullable(new Person(&quot;韩信&quot;,21, Status.FREE));</span><br><span class="line">        Optional&lt;String&gt; s &#x3D; optionalPerson.map(Person::getUserName);</span><br><span class="line">        System.out.println(s.get());</span><br><span class="line"></span><br><span class="line">        Optional&lt;String&gt; s1 &#x3D; optionalPerson.flatMap((e) -&gt; Optional.of(e.getUserName()));</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test4()&#123;</span><br><span class="line">        Optional&lt;Person&gt; optionalPerson &#x3D; Optional.ofNullable(new Person());</span><br><span class="line">        if (optionalPerson.isPresent())</span><br><span class="line">        System.out.println(optionalPerson.get());</span><br><span class="line"></span><br><span class="line">        Person person &#x3D; optionalPerson.orElseGet(() -&gt; new Person());</span><br><span class="line"></span><br><span class="line">        System.out.println(person);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test3()&#123;</span><br><span class="line">        Optional&lt;Person&gt; optionalPerson &#x3D; Optional.ofNullable(new Person());</span><br><span class="line"></span><br><span class="line">        System.out.println(optionalPerson.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test2()&#123;</span><br><span class="line">        Optional&lt;Person&gt; optionalPerson &#x3D; Optional.empty();</span><br><span class="line">        System.out.println(optionalPerson.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test1()&#123;</span><br><span class="line">        Optional&lt;Person&gt; person &#x3D; Optional.of(new Person());</span><br><span class="line">        System.out.println(person.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date Time API"></a>Date Time API</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">public class TestLocalDateTime &#123;</span><br><span class="line">    &#x2F;&#x2F;DateTimeFormatter  : 格式化时间&#x2F;日期</span><br><span class="line">    @Test</span><br><span class="line">    public void test6()&#123;</span><br><span class="line">        DateTimeFormatter isoDateTime &#x3D; DateTimeFormatter.ISO_DATE;</span><br><span class="line">        LocalDateTime ldt &#x3D; LocalDateTime.now();</span><br><span class="line">        String format &#x3D; isoDateTime.format(ldt);</span><br><span class="line">        System.out.println(format);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------------------------&quot;);</span><br><span class="line">        DateTimeFormatter dateTimeFormatter &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);</span><br><span class="line">        String format1 &#x3D; dateTimeFormatter.format(ldt);</span><br><span class="line">        System.out.println(format1);</span><br><span class="line"></span><br><span class="line">        LocalDateTime parse &#x3D; ldt.parse(format1,dateTimeFormatter);</span><br><span class="line">        System.out.println(parse);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;TemporalAdjuster : 时间校正器</span><br><span class="line">    @Test</span><br><span class="line">    public void  test5()&#123;</span><br><span class="line">        LocalDateTime ldt &#x3D; LocalDateTime.now();</span><br><span class="line">        System.out.println(ldt);</span><br><span class="line"></span><br><span class="line">        LocalDateTime ldt2 &#x3D; ldt.withDayOfMonth(10);</span><br><span class="line">        System.out.println(ldt2);</span><br><span class="line"></span><br><span class="line">        LocalDateTime ldt3 &#x3D; ldt.with(TemporalAdjusters.next(DayOfWeek.SUNDAY));</span><br><span class="line">        System.out.println(ldt3);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;自定义 : 下一个工作日</span><br><span class="line">        ldt3.with((x) -&gt; &#123;</span><br><span class="line">            LocalDateTime ldt4 &#x3D; (LocalDateTime)x;</span><br><span class="line">            DayOfWeek dow &#x3D; ldt4.getDayOfWeek();</span><br><span class="line">            if (dow.equals(DayOfWeek.FRIDAY))&#123;</span><br><span class="line">                return ldt4.plusDays(3);</span><br><span class="line">            &#125;else if (dow.equals(DayOfWeek.SATURDAY))&#123;</span><br><span class="line">                return ldt4.plusDays(2);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                return ldt4.plusDays(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;3. Duration : 计算两个时间之间的间隔</span><br><span class="line">    &#x2F;&#x2F;Period : 计算两个日期之间的间隔</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test4()&#123;</span><br><span class="line">        LocalDate ld1 &#x3D; LocalDate.of(2020, 1, 1);</span><br><span class="line">        LocalDate ld2 &#x3D; LocalDate.now();</span><br><span class="line">        Period period &#x3D; Period.between(ld1,ld2);</span><br><span class="line">        System.out.println(period);</span><br><span class="line">        System.out.println(&quot;年:&quot;+period.getYears()+&quot;--月:&quot;+period.getMonths()+&quot;--日:&quot;+period.getDays()+&quot;--年代学:&quot;+period.getChronology()+&quot;--\n&quot; +</span><br><span class="line">                &quot;\n&quot; +</span><br><span class="line">                &quot;单位 :&quot;+period.getUnits());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test3()&#123;</span><br><span class="line">        &#x2F;&#x2F;Duration : 计算两个时间之间的间隔</span><br><span class="line">        Instant now &#x3D; Instant.now();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Instant now1 &#x3D; Instant.now();</span><br><span class="line">        Duration duration &#x3D; Duration.between(now, now1);</span><br><span class="line">        System.out.println(duration.toMillis());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;2. Instant :时间戳(Unix 元年:1970 年1月1日 00:00:00 到某个时间之间的毫秒值)</span><br><span class="line">    @Test</span><br><span class="line">    public void test2()&#123;</span><br><span class="line">        Instant now &#x3D; Instant.now();</span><br><span class="line">        System.out.println(Instant.now());</span><br><span class="line"></span><br><span class="line">        OffsetDateTime offsetDateTime &#x3D; Instant.now().atOffset(ZoneOffset.ofHours(8));</span><br><span class="line">        System.out.println(offsetDateTime);</span><br><span class="line"></span><br><span class="line">        System.out.println(now.toEpochMilli());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;1. LocalTime  LocalDate  LocalDateTime</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public  void test1() &#123;</span><br><span class="line">        LocalDateTime now &#x3D; LocalDateTime.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line"></span><br><span class="line">        LocalDateTime of &#x3D; LocalDateTime.of(2020, 4, 17, 16, 40);</span><br><span class="line">        System.out.println(of);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">三月三</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zysheep.cn/2018/04/10/JavaSE/jdk1.8/40/">https://zysheep.cn/2018/04/10/JavaSE/jdk1.8/40/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zysheep.cn" target="_blank">三月三</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaSE/">JavaSE</a><a class="post-meta__tags" href="/tags/JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7/">JDK1.8新特性</a></div><div class="post_share"><div class="social-share" data-image="http://cdn.panyucable.cn/zysheep/wallhaven-n673pw.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="https://cdn.jsdelivr.net/gh/zysheep/picgo-imgs/imgwechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="https://cdn.jsdelivr.net/gh/zysheep/picgo-imgs/imgalipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2018/04/11/JavaEE/El%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><img class="prev_cover" src="http://cdn.panyucable.cn/zysheep/1737x1152.jfif" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">El表达式</div></div></a></div><div class="next-post pull_right"><a href="/2018/04/09/JavaSE/jdk1.5/41/"><img class="next_cover" src="http://cdn.panyucable.cn/zysheep/1024x640.jfif" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java1.5-注解</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/04/08/JVM/39/" title="Heap 堆"><img class="relatedPosts_cover" src="http://cdn.panyucable.cn/zysheep/jw_jvm_overview_3x2_1200x800-100758586-large.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-04-08</div><div class="relatedPosts_title">Heap 堆</div></div></a></div><div class="relatedPosts_item"><a href="/2019/04/07/JVM/38/" title="JVM体系结构概述"><img class="relatedPosts_cover" src="http://cdn.panyucable.cn/zysheep/jw_jvm_overview_3x2_1200x800-100758586-large.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-04-07</div><div class="relatedPosts_title">JVM体系结构概述</div></div></a></div><div class="relatedPosts_item"><a href="/2018/04/09/JavaSE/jdk1.5/41/" title="Java1.5-注解"><img class="relatedPosts_cover" src="http://cdn.panyucable.cn/zysheep/1024x640.jfif"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-04-09</div><div class="relatedPosts_title">Java1.5-注解</div></div></a></div><div class="relatedPosts_item"><a href="/2018/04/06/JavaSE/Collection/35/" title="Set接口"><img class="relatedPosts_cover" src="http://cdn.panyucable.cn/zysheep/1962x1307.jfif"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-04-06</div><div class="relatedPosts_title">Set接口</div></div></a></div><div class="relatedPosts_item"><a href="/2018/04/06/JavaSE/Collection/37/" title="Java 数据结构"><img class="relatedPosts_cover" src="http://cdn.panyucable.cn/zysheep/1476x923.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-04-06</div><div class="relatedPosts_title">Java 数据结构</div></div></a></div><div class="relatedPosts_item"><a href="/2018/04/06/JavaSE/Collection/36/" title="Java 序列化"><img class="relatedPosts_cover" src="http://cdn.panyucable.cn/zysheep/1644x1094.jfif"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-04-06</div><div class="relatedPosts_title">Java 序列化</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '502b8308721b081071a5',
  clientSecret: '35220d15c7f8aaf585d6822cf5d49fedf5b602d6',
  repo: 'blog-comment',
  owner: 'zysheep',
  admin: ['zysheep'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  perPage: 10,
  distractionFreeMode: false,
  pagerDirection: 'last',
  createIssueManually: false,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" style="background-image: url(http://cdn.panyucable.cn/zysheep/2026x1136.jfif)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By 三月三</div><div class="footer_custom_text">生活不只是眼前的苟且,还有诗和远方</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/third-party/click_heart.js"></script><script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/js/hideCategory.min.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>