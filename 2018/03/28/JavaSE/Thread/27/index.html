<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>多线程(Thread) | 三月三漫画</title><meta name="description" content="1. 进程几乎所有操作系统都支持进程的概念，所有运行中的任务通常对应一条进程(Process)。当一个程序进入内存运行，即变成一个进程。进程是处于运行过程中的程序，并且具有一定独立功能，进程是系统进行资源分配和调度的一个独立单位。       1.1进程包含如下三个特征: 独立性:进程是系统中独立存在的实体，它可以拥有自己独立的资源，每一个进程都拥有自己私有的地址空间。在没有经过进程本身允许的情况"><meta name="keywords" content="JavaSE"><meta name="author" content="三月三"><meta name="copyright" content="三月三"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="dns-prefetch" href="https://hm.baidu.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="多线程(Thread)"><meta name="twitter:description" content="1. 进程几乎所有操作系统都支持进程的概念，所有运行中的任务通常对应一条进程(Process)。当一个程序进入内存运行，即变成一个进程。进程是处于运行过程中的程序，并且具有一定独立功能，进程是系统进行资源分配和调度的一个独立单位。       1.1进程包含如下三个特征: 独立性:进程是系统中独立存在的实体，它可以拥有自己独立的资源，每一个进程都拥有自己私有的地址空间。在没有经过进程本身允许的情况"><meta name="twitter:image" content="http://qanu3nz77.bkt.clouddn.com/zysheep/1920x1018.jfif"><meta property="og:type" content="article"><meta property="og:title" content="多线程(Thread)"><meta property="og:url" content="https://zysheep.cn/2018/03/28/JavaSE/Thread/27/"><meta property="og:site_name" content="三月三漫画"><meta property="og:description" content="1. 进程几乎所有操作系统都支持进程的概念，所有运行中的任务通常对应一条进程(Process)。当一个程序进入内存运行，即变成一个进程。进程是处于运行过程中的程序，并且具有一定独立功能，进程是系统进行资源分配和调度的一个独立单位。       1.1进程包含如下三个特征: 独立性:进程是系统中独立存在的实体，它可以拥有自己独立的资源，每一个进程都拥有自己私有的地址空间。在没有经过进程本身允许的情况"><meta property="og:image" content="http://qanu3nz77.bkt.clouddn.com/zysheep/1920x1018.jfif"><meta property="article:published_time" content="2018-03-28T13:30:45.000Z"><meta property="article:modified_time" content="2020-05-23T03:04:13.673Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://zysheep.cn/2018/03/28/JavaSE/Thread/27/"><link rel="prev" title="Java 多线程编程" href="https://zysheep.cn/2018/03/29/JavaSE/Thread/28/"><link rel="next" title="包(package)" href="https://zysheep.cn/2018/03/27/JavaSE/OOP/26/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7f671f0f6d996680d21d5c32a23a9313";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://zysheep.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/hideCategory.min.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/zysheep/picgo-imgs/img41.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">106</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">32</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-bug" aria-hidden="true"></i><span> Language</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/java/"><i class="fa-fw fa fa-coffee"></i><span> Java</span></a></li><li><a class="site-page" href="/python/"><i class="fa-fw fa fa-binoculars"></i><span> Python</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-picture-o"></i><span> Gallery</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> movies</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-进程"><span class="toc-number">1.</span> <span class="toc-text">1. 进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1进程包含如下三个特征"><span class="toc-number">1.1.</span> <span class="toc-text">1.1进程包含如下三个特征:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-区别"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-线程的创建和启动"><span class="toc-number">2.</span> <span class="toc-text">2. 线程的创建和启动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-继承Thread类创建线程类"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 继承Thread类创建线程类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-实现Runnable接口创建线程类"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 实现Runnable接口创建线程类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-实现Callable接口创建线程类"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 实现Callable接口创建线程类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-两种方式所创建线程的对比"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 两种方式所创建线程的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#start-方法使用的-静态代理"><span class="toc-number">2.5.</span> <span class="toc-text">start()方法使用的 静态代理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-线程的生命周期"><span class="toc-number">3.</span> <span class="toc-text">3. 线程的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-新建和就绪状态"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 新建和就绪状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-运行和阻塞状态"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 运行和阻塞状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-线程死亡"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 线程死亡</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-线程安全"><span class="toc-number">4.</span> <span class="toc-text">4. 线程安全</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-死锁"><span class="toc-number">5.</span> <span class="toc-text">5. 死锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-线程通信"><span class="toc-number">6.</span> <span class="toc-text">6. 线程通信</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-Thread中的一些方法"><span class="toc-number">7.</span> <span class="toc-text">7. Thread中的一些方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-如何停止线程"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 如何停止线程?</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(http://qanu3nz77.bkt.clouddn.com/zysheep/1920x1018.jfif)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">三月三漫画</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-bug" aria-hidden="true"></i><span> Language</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/java/"><i class="fa-fw fa fa-coffee"></i><span> Java</span></a></li><li><a class="site-page" href="/python/"><i class="fa-fw fa fa-binoculars"></i><span> Python</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-picture-o"></i><span> Gallery</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> movies</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">多线程(Thread)</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2018-03-28 21:30:45"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2018-03-28</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-23 11:04:13"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-23</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JavaSE/">JavaSE</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JavaSE/Java%E9%AB%98%E7%BA%A7%E7%AF%87/">Java高级篇</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">4.4k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 14 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2018/03/28/JavaSE/Thread/27/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h1><p>几乎所有操作系统都支持进程的概念，所有运行中的任务通常对应一条进程(Process)。当<strong>一个程序进入内存运行，即变成一个进程</strong>。进程是处于运行过程中的程序，并且具有一定独立功能，进程是<strong>系统进行资源分配和调度</strong>的一个<strong>独立单位</strong>。      </p>
<h2 id="1-1进程包含如下三个特征"><a href="#1-1进程包含如下三个特征" class="headerlink" title="1.1进程包含如下三个特征:"></a>1.1进程包含如下三个特征:</h2><ul>
<li><strong>独立性</strong>:进程是系统中<strong>独立存在</strong>的实体，它可以拥有自己<strong>独立的资源</strong>，每一个进程都拥有自己<strong>私有的地址空间</strong>。在没有经过进程本身允许的情况下，一个用户进程不可以直接访问其他进程的地址空间。</li>
<li><strong>动态性</strong>:进程与程序的区别在于，<strong>程序</strong>只是一个<strong>静态的指令集合</strong>，而<strong>进程</strong>是一个<strong>正在系统中活动的指令集合</strong>。在进程中加入了时间的概念。进程具有自己的<strong>生命周期</strong>和各种<strong>不同的状态</strong>，这些概念在程序中都是不具备的。</li>
<li><strong>并发性</strong>:多个进程可以在<strong>单个处理器</strong>上并发执行，多个进程之间不会互相影响。<h2 id="1-2-区别"><a href="#1-2-区别" class="headerlink" title="1.2 区别"></a>1.2 区别</h2></li>
</ul>
<ol>
<li>并发性(concurrency)和并行性(parallel)是两个概念，<strong>并行</strong>指在<strong>同一时刻</strong>，有<strong>多条指令</strong>在<strong>多个处理器上</strong>同时执行；<strong>并发</strong>指在<strong>同一时刻只能有一条指令执行</strong>，但多个进程指令被<strong>快速轮换</strong>执行，使得在宏观上具有多个进程同时执行的效果。</li>
<li><strong>多线程</strong>则扩展了多进程的概念，使得同<strong>一个进程</strong>可以同时<strong>并发处理多个任务</strong>。线程(Thread)也被称作轻量级进程(Lightweight Process)，<strong>线程是进程的执行单元</strong>。就像进程在操作系统中的地位一样，线程在程序中是<strong>独立的、并发的执行流</strong>。当<strong>进程被初始化</strong>后，主线程就被创建了。对于绝大多数的应用程序来说，通常仅要求有一个主线程，但我们也可以在该进程内创建多条顺序执行流，这些<strong>顺序执行流就是线程，每条线程也是互相独立的。</strong>  </li>
<li>线程是进程的组成部分，一个<strong>进程</strong>可以拥有<strong>多个线程</strong>，<strong>一个线程</strong>必须有<strong>一个父进程</strong>。线程可以拥有自己的堆栈、自己的程序计数器和自己的局部变量，但<strong>不再拥有系统资源</strong>，它与父进程的<strong>其他线程共享该进程所拥有的全部资源</strong>。因为多个线程共享父进程里的全部资源，因此编程更加方便;但必须更加小心，我们必须确保线程不会妨碍同一进程里的其他线程。</li>
<li><strong>一个程序运行后至少有一个进程，一个进程里可以包含多个线程，但至少要包含一个线程。</strong></li>
<li>线程共享的环境包括:<strong>进程代码段</strong>、<strong>进程的公有数据</strong>等。利用这些共享的数据等，线程很容易实现相互之间的通信。</li>
</ol>
<blockquote>
<p>多线程的优点:</p>
</blockquote>
<ul>
<li>进程间不能共享内存，但线程之间共享内存非常容易。</li>
<li>系统创建进程需要为该进程重新分配系统资源，但创建线程则代价小得多，因此使用多线程来实现多任务并发比多进程的效率高。</li>
<li>Java语言内置多线程功能支持，而不是单纯地作为底层操作系统的调度方式，从而简化了Java的多线程编。</li>
</ul>
<h1 id="2-线程的创建和启动"><a href="#2-线程的创建和启动" class="headerlink" title="2. 线程的创建和启动"></a>2. 线程的创建和启动</h1><p>Java使用Thread类代表线程，所有的<strong>线程对象</strong>都必须是<strong>Thread类或其子类的实例</strong>。每条线程的作用是完成一定的任务，实际上就是<strong>执行一段程序流</strong>(一段顺序执行的代码)。Java使用<strong>run方法来封装这样一段程序流。</strong></p>
<h2 id="2-1-继承Thread类创建线程类"><a href="#2-1-继承Thread类创建线程类" class="headerlink" title="2.1 继承Thread类创建线程类"></a>2.1 继承Thread类创建线程类</h2><p>通过继承Thread类来创建并启动多线程的步骤如下:</p>
<ol>
<li>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就是代表了线程需要完成的任务。因此，我们经常把<strong>run方法称为线程执行体</strong>。</li>
<li>创建Thread子类的实例，即使创建了线程对象。</li>
<li>用线程对象的start方法来启动该线程。</li>
</ol>
<h2 id="2-2-实现Runnable接口创建线程类"><a href="#2-2-实现Runnable接口创建线程类" class="headerlink" title="2.2 实现Runnable接口创建线程类"></a>2.2 实现Runnable接口创建线程类</h2><p>实现Runnable接口来创建并启动多条线程的步骤如下:</p>
<ol>
<li>定义Runnable接口的实现类，并重写该接口的run方法，该run方法的方法体同样是该线程的线程执行体</li>
<li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li>
<li>使用Runnable接口创建线程可以共享<strong>同一个线程类实例</strong>的资源。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;实现Runnable 可以共享一份数据   存再并发问题</span><br><span class="line">public class Racer implements Runnable&#123;</span><br><span class="line">    private String winner;&#x2F;&#x2F;胜利者</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int steps&#x3D;1;steps&lt;&#x3D;100;steps++)&#123;</span><br><span class="line">            if (Thread.currentThread().getName().equals(&quot;rabbit&quot;)&amp;&amp;steps%10&#x3D;&#x3D;0)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+steps);</span><br><span class="line">            boolean flag&#x3D; gameOver(steps);</span><br><span class="line">            if (flag)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean gameOver(int steps)&#123;</span><br><span class="line">        if (winner!&#x3D;null)&#123;&#x2F;&#x2F;存在胜利者</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if (steps&#x3D;&#x3D;100)&#123;</span><br><span class="line">                winner&#x3D;Thread.currentThread().getName();</span><br><span class="line">                System.out.println(&quot;winner&#x3D;&#x3D;&gt;&quot;+winner);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;一份资源</span><br><span class="line">        Racer racer &#x3D; new Racer();</span><br><span class="line">        &#x2F;&#x2F;多个代理</span><br><span class="line">        new Thread(racer,&quot;rabbit&quot;).start();</span><br><span class="line">        new Thread(racer,&quot;tortoise&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-3-实现Callable接口创建线程类"><a href="#2-3-实现Callable接口创建线程类" class="headerlink" title="2.3 实现Callable接口创建线程类"></a>2.3 实现Callable接口创建线程类</h2><p>实现Callable接口来创建并启动多条线程的步骤如下:</p>
<ol>
<li>定义Callable接口的实现类,并重写call方法,该call方法的方法体同样是该线程的线程执行体</li>
<li>区别:可以抛异常,和返回的对象类型</li>
</ol>
<h2 id="2-4-两种方式所创建线程的对比"><a href="#2-4-两种方式所创建线程的对比" class="headerlink" title="2.4 两种方式所创建线程的对比"></a>2.4 两种方式所创建线程的对比</h2><p>采用实现Runnable接口方式的多线程:</p>
<ul>
<li>线程类只是实现了Runnable接口，还可以继承其他类。</li>
<li>在这种方式下，可以多个线程共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li>
<li>劣势是:编程稍稍复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。</li>
</ul>
<p>采用继承Thread类方式的多线程:</p>
<ul>
<li>劣势是:因为线程类已经继承了Thread类，所以不能再继承其他父类。</li>
<li>优势是:编写简单，如果需要访问当前线程，无须使用Thread.currentThread()方法，直接使用this即可获得当前线程。</li>
</ul>
<blockquote>
<p>实际上几乎所有的多线程应用都可采用第一种方式，也就是实现Runnable接口的方式。</p>
</blockquote>
<h2 id="start-方法使用的-静态代理"><a href="#start-方法使用的-静态代理" class="headerlink" title="start()方法使用的 静态代理"></a>start()方法使用的 静态代理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* 静态代理</span><br><span class="line">* 实现同一个接口</span><br><span class="line">* 1. 真是角色</span><br><span class="line">* 2.代理角色:必须有真实角色的目标对象</span><br><span class="line">*</span><br><span class="line">* *&#x2F;</span><br><span class="line">public class staticPoxy &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new WeddingCompany(new You()).HappuMarry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;接口</span><br><span class="line">interface  marry&#123;</span><br><span class="line">   void HappuMarry();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;真实角色</span><br><span class="line">class  You implements  marry&#123;</span><br><span class="line"></span><br><span class="line">    public void HappuMarry() &#123;</span><br><span class="line">        System.out.println(&quot;我要结婚了,非常舒服&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;代理角色:有真实角色的目标对象</span><br><span class="line">class  WeddingCompany implements  marry&#123;</span><br><span class="line">   private You you;</span><br><span class="line">   public   WeddingCompany(You you)&#123;</span><br><span class="line">    this.you&#x3D;you;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void HappuMarry() &#123;</span><br><span class="line">     realdy();</span><br><span class="line">     this.you.HappuMarry();</span><br><span class="line">     after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void realdy() &#123;</span><br><span class="line">        System.out.println(&quot;布置现场---&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void after() &#123;</span><br><span class="line">        System.out.println(&quot;闹新房---&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-线程的生命周期"><a href="#3-线程的生命周期" class="headerlink" title="3. 线程的生命周期"></a>3. 线程的生命周期</h1><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态，在线程的生命周期中，它要经过<strong>新建（new)、就绪(Runnable start()）、运行(Running,cpu调度)、阻塞(Blocked)和死亡(Dead(定义标志,外部结束))五种状态</strong>。尤其是当线程启动以后，它不能一直“霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会<strong>多次在运行、阻塞之间</strong>切换。<br><img src="http://qanu3nz77.bkt.clouddn.com/zysheep/thred1.png" alt=""><br><img src="http://qanu3nz77.bkt.clouddn.com/zysheep/thread2.png" alt=""></p>
<h2 id="3-1-新建和就绪状态"><a href="#3-1-新建和就绪状态" class="headerlink" title="3.1 新建和就绪状态"></a>3.1 新建和就绪状态</h2><p><strong>新建</strong>:当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他Java对象一样，仅仅由Java虚拟机为其分配了内存，并初始化了其成员变量的值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程执行体中的线程执行体。<br><strong>就绪</strong>:当线程对象调用了start()方法之后，该线程处于就绪状态，Java虚拟机会为其创建方法调用栈和程序计数器,处于这个状态中的线程并没有开始运行，它只是表示该线程可以运行了。至于该线程何时开始运行取决于jvm里线程调度器的调度。</p>
<blockquote>
<p>不要对已经处于启动状态的线程再次调用start()方法，否则将引发IllegalThreadStateException异常。      </p>
</blockquote>
<h2 id="3-2-运行和阻塞状态"><a href="#3-2-运行和阻塞状态" class="headerlink" title="3.2 运行和阻塞状态"></a>3.2 运行和阻塞状态</h2><p><strong>运行</strong>:如果处于就绪状态的线程获得了CPU，开始执行run方法的线程执行体，则该线程处于运行状态，如果计算机只有一个CPU，在任何时刻只有一条线程处于运行状态。当然，在一个多处理器的机器上，将会有多个线程并行(注意是并行:parallel)执行;但当线程数大于处理器数时，依然会有多条线程在同一个CPU上轮换的现象。<br><strong>阻塞</strong>:当发生如下情况下，线程将会进入阻塞状态:</p>
<ul>
<li>线程调用sleep方法主动放弃所占用的处理器资源。(抱着资源睡觉)</li>
<li>线程调用了一个阻塞式io方法，在该方法返回之前，该线程被阻塞。</li>
<li>线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。</li>
<li>线程调用wait()方法进入阻塞状态</li>
<li>线程调用join()方法合并线程,当前线程进入阻塞状态   </li>
</ul>
<blockquote>
<p>当运行状态的线程<strong>失去处理器资源</strong>时，该线程进入<strong>就绪状态</strong>。但有一个方法例外，调用yield()可以让当前处于运行状态的线程转入就绪状态.</p>
</blockquote>
<h2 id="3-3-线程死亡"><a href="#3-3-线程死亡" class="headerlink" title="3.3 线程死亡"></a>3.3 线程死亡</h2><p>线程会以以下三种方式之一结束,结束后就处于死亡状态:</p>
<ul>
<li>run()方法执行完成,线程正常结束;</li>
<li>线程抛出一个未捕获的Exception或Error</li>
<li>直接调用线程的stop()方法来结束该线程.该方法容易导致死锁,通常不推荐使用</li>
</ul>
<blockquote>
<p>注: 当主线程结束时候，其他线程不受任何影响，并不会随之结束。一旦子线程启动起来后，它就拥有和主线程相同的地位，它不会受主线程的影响。</p>
</blockquote>
<p>总结:</p>
<ol>
<li><strong>进程:</strong>是一个正在执行中的程序,每一个进程执行都有一个执行顺序,该顺序是一个执行路劲,或者叫一个控制单元</li>
<li><strong>线程:</strong>就是进程中的一个独立的控制单元。线程在控制着进程的执行。</li>
<li>一个进程中至少有一个线程。</li>
<li>JVM启动的时候会有一个进程java.exe.该进程中至少一个线程负责java程序的执行。而且这个线程运行的代码存在于main方法中。该线程称之为主线程。</li>
<li><strong>扩展</strong>：其实更细节说明jvm，jvm启动不止一个线程，还有负责垃圾回收机制的线程。</li>
<li>如何在自定义的代码中，自定义一个线程呢？</li>
</ol>
<ul>
<li>通过对api的查找，java已经提供了对线程这类事物的描述。就Thread类。</li>
<li>创建线程的第一种方式：继承Thread类。</li>
<li>定义类继承Thread。复写Thread类中的run方法。目的：将自定义代码存储在run方法。让线程运行。</li>
<li>调用线程的start方法，该方法两个作用：启动线程，调用run方法。</li>
</ul>
<ol start="7">
<li>发现运行结果每一次都不同。因为多个线程都获取cpu的执行权。cpu执行到谁，谁就运行。<strong>明确一点，在某一个时刻，只能有一个程序在运行</strong>。(多核除外)cpu在做着快速的切换，以达到看上去是同时运行的效果。我们可以形象把多线程的运行行为在互相抢夺cpu的执行权。</li>
<li>为什么要覆盖run方法呢？</li>
</ol>
<ul>
<li>Thread类用于描述线程。该类就定义了一个功能，用于存储线程要运行的代码。该存储功能就是run方法。也就是说Thread类中的run方法，用于存储线程要运行的代码。</li>
</ul>
<ol start="9">
<li>创建线程的第二种方式：实现Runable接口</li>
</ol>
<ul>
<li>定义类实现Runnable接口</li>
<li>覆盖Runnable接口中的run方法。将线程要运行的代码存放在该run方法中。</li>
<li>通过Thread类建立线程对象。</li>
<li>将Runnable接口的子类对象作为实际参数传递给Thread类的构造函数。</li>
<li>调用Thread类的start方法开启线程并调用Runnable接口子类的run方法。</li>
</ul>
<ol start="10">
<li>实现方式和继承方式有什么区别呢？</li>
</ol>
<ul>
<li>实现方式好处：避免了单继承的局限性。实现方式好处：避免了单继承的局限性。</li>
</ul>
<h1 id="4-线程安全"><a href="#4-线程安全" class="headerlink" title="4. 线程安全"></a>4. 线程安全</h1><ol>
<li>问题的原因：当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。</li>
<li>解决办法：对多条操作共享数据的语句，只能让一个线程都执行完。在执行过程中，其他线程不可以参与执行。Java对于多线程的安全问题提供了专业的解决方式。就是同步代码块。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象)&#123;</span><br><span class="line">    需要被同步的代码 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对象</strong>如同锁。持有锁的线程可以在同步中执行。没有持有锁的线程即使获取cpu的执行权，也进不去，因为没有获取锁。<br>3. 同步的前提：必须要有两个或者两个以上的线程。必须是多个线程使用同一个锁。必须保证同步中只能有一个线程在运行。<br>4. 好处：解决了多线程的安全问题。<br>5. 弊端：多个线程需要判断锁，较为消耗资源<br>6. 同步函数用的是哪一个锁呢？</p>
<ul>
<li>函数需要被对象调用。那么函数都有一个所属对象引用。就是this。所以同步函数使用的锁是this。</li>
</ul>
<ol start="7">
<li>如果同步函数被静态修饰后，使用的锁是什么呢？</li>
</ol>
<ul>
<li>通过验证，发现不在是this。因为静态方法中也不可以定义this。静态进内存是，内存中没有本类对象，但是一定有该类对应的字节码文件对象。类名.class  该对象的类型是Class</li>
</ul>
<ol start="8">
<li>如何找问题：</li>
</ol>
<ul>
<li>明确哪些代码是多线程运行代码。</li>
<li>明确共享数据。</li>
<li>明确多线程运行代码中哪些语句是操作共享数据的。    </li>
</ul>
<h1 id="5-死锁"><a href="#5-死锁" class="headerlink" title="5. 死锁"></a>5. 死锁</h1><p>当两个线程相互等待对方释放同步监视器时就会发生死锁，Java虚拟机没有监测，也没有采用措施来处理死锁情况，所以多线程编程时应该采取措施避免死锁的出现。一旦出现死锁，整个程序既不会发生任何异常，也不会给出任何提示，只是所有线程处于阻塞状态，无法继续。</p>
<h1 id="6-线程通信"><a href="#6-线程通信" class="headerlink" title="6. 线程通信"></a>6. 线程通信</h1><p>在同步代码中可以使用锁对象的wait()方法让当前线程等待使用锁对象的notify()方法可以将正在等待的线程唤醒如果多个线程都在等待，notify()唤醒随机1个notifyAll()方法可以唤醒所有在等待的线程</p>
<h1 id="7-Thread中的一些方法"><a href="#7-Thread中的一些方法" class="headerlink" title="7. Thread中的一些方法"></a>7. Thread中的一些方法</h1><h2 id="7-1-如何停止线程"><a href="#7-1-如何停止线程" class="headerlink" title="7.1 如何停止线程?"></a>7.1 如何停止线程?</h2><p>只有一种，run方法结束。开启多线程运行，运行代码通常是循环结构。只要控制住循环，就可以让run方法结束，也就是线程结束<br><strong>特殊情况:</strong> 当线程处于了冻结状态。就不会读取到标记。那么线程就不会结束。当没有指定的方式让冻结的线程恢复到运行状态是，这时需要对冻结进行清除。强制让线程恢复到运行状态中来。这样就可以操作标记让线程结束。Thread类提供该方法 interrupt();<br><strong>join:</strong> 当A线程执行到了B线程的.join()方法时，A就会等待。等B线程都执行完，A才会执行。join可以用来临时加入线程执行<br><strong>yield:</strong> 暂停当前正在执行的线程对象，并执行其他线程。<br><strong>后台线程有个特征:如果所有的前台线程都死亡，后台线程会自动死亡。</strong><br><strong>sleep:</strong>   线程调用sleep方法主动放弃所占用的处理器资源。(抱着资源睡觉)</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">三月三</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zysheep.cn/2018/03/28/JavaSE/Thread/27/">https://zysheep.cn/2018/03/28/JavaSE/Thread/27/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zysheep.cn" target="_blank">三月三漫画</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaSE/">JavaSE</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zysheep/picgo-imgs/img2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="https://cdn.jsdelivr.net/gh/zysheep/picgo-imgs/imgwechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="https://cdn.jsdelivr.net/gh/zysheep/picgo-imgs/imgalipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2018/03/29/JavaSE/Thread/28/"><img class="prev_cover" src="http://qanu3nz77.bkt.clouddn.com/zysheep/1536x1058.jfif" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java 多线程编程</div></div></a></div><div class="next-post pull_right"><a href="/2018/03/27/JavaSE/OOP/26/"><img class="next_cover" src="http://qanu3nz77.bkt.clouddn.com/zysheep/280x800.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">包(package)</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2018/04/10/JavaSE/jdk1.8/40/" title="Java 8 新特性"><img class="relatedPosts_cover" src="http://qanu3nz77.bkt.clouddn.com/zysheep/1921x1211.jfif"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-04-10</div><div class="relatedPosts_title">Java 8 新特性</div></div></a></div><div class="relatedPosts_item"><a href="/2018/04/09/JavaSE/jdk1.5/41/" title="Java1.5-注解"><img class="relatedPosts_cover" src="http://qanu3nz77.bkt.clouddn.com/zysheep/1921x1116.jfif"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-04-09</div><div class="relatedPosts_title">Java1.5-注解</div></div></a></div><div class="relatedPosts_item"><a href="/2018/04/08/JVM/39/" title="Heap 堆"><img class="relatedPosts_cover" src="http://qanu3nz77.bkt.clouddn.com/zysheep/1322x1020.jfif"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-04-08</div><div class="relatedPosts_title">Heap 堆</div></div></a></div><div class="relatedPosts_item"><a href="/2018/04/07/JVM/38/" title="JVM体系结构概述"><img class="relatedPosts_cover" src="http://qanu3nz77.bkt.clouddn.com/zysheep/1927x1080.jfif"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-04-07</div><div class="relatedPosts_title">JVM体系结构概述</div></div></a></div><div class="relatedPosts_item"><a href="/2018/04/06/JavaSE/Collection/35/" title="Set接口"><img class="relatedPosts_cover" src="http://qanu3nz77.bkt.clouddn.com/zysheep/1536x1058.jfif"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-04-06</div><div class="relatedPosts_title">Set接口</div></div></a></div><div class="relatedPosts_item"><a href="/2018/04/06/JavaSE/Collection/36/" title="Java 序列化"><img class="relatedPosts_cover" src="http://qanu3nz77.bkt.clouddn.com/zysheep/1921x1080.jfif"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-04-06</div><div class="relatedPosts_title">Java 序列化</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '7aaa3f830ce67c87d829',
  clientSecret: 'e50657367f1240f2c12596cac63badfaae13fe3b',
  repo: 'blog-comment',
  owner: 'zysheep',
  admin: ['zysheep'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  perPage: 10,
  distractionFreeMode: false,
  pagerDirection: 'last',
  createIssueManually: false,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" style="background-image: url(http://qanu3nz77.bkt.clouddn.com/zysheep/1920x1018.jfif)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By 三月三</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text"><a href="http://zysheep.github.io/" target="_blank" rel="noopener">三月三</a>,专门为你制造快乐的网站</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/third-party/click_heart.js"></script><script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/js/hideCategory.min.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>