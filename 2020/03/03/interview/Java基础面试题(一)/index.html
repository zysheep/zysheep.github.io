<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java面试题(一) | 三月三</title><meta name="description" content="Java面试题（一）1、面向对象的特征有哪些方面？ 2、访问修饰符 public,private,protected,以及不写（默认）时的区别？ 3、String 是最基本的数据类型吗？ 4、float f&#x3D;3.4;是否正确？ 5、short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗？ 6、Java 有没有 goto？ 7、int 和 In"><meta name="keywords" content="面试宝典"><meta name="author" content="三月三"><meta name="copyright" content="三月三"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="http://cdn.panyucable.cn/zysheep/ico.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="dns-prefetch" href="https://hm.baidu.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java面试题(一)"><meta name="twitter:description" content="Java面试题（一）1、面向对象的特征有哪些方面？ 2、访问修饰符 public,private,protected,以及不写（默认）时的区别？ 3、String 是最基本的数据类型吗？ 4、float f&#x3D;3.4;是否正确？ 5、short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗？ 6、Java 有没有 goto？ 7、int 和 In"><meta name="twitter:image" content="http://cdn.panyucable.cn/zysheep/1927x1080.jfif"><meta property="og:type" content="article"><meta property="og:title" content="Java面试题(一)"><meta property="og:url" content="https://zysheep.cn/2020/03/03/interview/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98(%E4%B8%80)/"><meta property="og:site_name" content="三月三"><meta property="og:description" content="Java面试题（一）1、面向对象的特征有哪些方面？ 2、访问修饰符 public,private,protected,以及不写（默认）时的区别？ 3、String 是最基本的数据类型吗？ 4、float f&#x3D;3.4;是否正确？ 5、short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗？ 6、Java 有没有 goto？ 7、int 和 In"><meta property="og:image" content="http://cdn.panyucable.cn/zysheep/1927x1080.jfif"><meta property="article:published_time" content="2020-03-02T16:00:00.000Z"><meta property="article:modified_time" content="2020-06-29T09:37:55.299Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://zysheep.cn/2020/03/03/interview/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98(%E4%B8%80)/"><link rel="prev" title="kafka面试题" href="https://zysheep.cn/2020/03/03/interview/kafka%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="next" title="Spring Boot入门" href="https://zysheep.cn/2020/03/02/Spring/Spring%20Boot%202.2.2/SpringBoot%E5%85%A5%E9%97%A8/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7f671f0f6d996680d21d5c32a23a9313";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://zysheep.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/hideCategory.min.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="http://cdn.panyucable.cn/zysheep/xiaoman.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">213</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">50</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">71</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-bug" aria-hidden="true"></i><span> 编程路线</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/java/"><i class="fa-fw fa fa-coffee"></i><span> Java</span></a></li><li><a class="site-page" href="/python/"><i class="fa-fw fa fa-binoculars"></i><span> Python</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-folder-open" aria-hidden="true"></i><span> 面试宝典</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/interview/"><i class="fa-fw fa fa-file-text-o"></i><span> Java面试题</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 我的生活</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-picture-o"></i><span> Gallery</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java面试题（一）"><span class="toc-number">1.</span> <span class="toc-text">Java面试题（一）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1、面向对象的特征有哪些方面？"><span class="toc-number">2.</span> <span class="toc-text">1、面向对象的特征有哪些方面？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、访问修饰符-public-private-protected-以及不写（默认）时的区别？"><span class="toc-number">3.</span> <span class="toc-text">2、访问修饰符 public,private,protected,以及不写（默认）时的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、String-是最基本的数据类型吗？"><span class="toc-number">4.</span> <span class="toc-text">3、String 是最基本的数据类型吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、float-f-3-4-是否正确？"><span class="toc-number">5.</span> <span class="toc-text">4、float f&#x3D;3.4;是否正确？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？"><span class="toc-number">6.</span> <span class="toc-text">5、short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、Java-有没有-goto？"><span class="toc-number">7.</span> <span class="toc-text">6、Java 有没有 goto？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7、int-和-Integer-有什么区别？"><span class="toc-number">8.</span> <span class="toc-text">7、int 和 Integer 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8、-amp-和-amp-amp-的区别？"><span class="toc-number">9.</span> <span class="toc-text">8、&amp;和&amp;&amp;的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9、解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法。"><span class="toc-number">10.</span> <span class="toc-text">9、解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10、Math-round-11-5-等于多少？Math-round-11-5-等于多少？"><span class="toc-number">11.</span> <span class="toc-text">10、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11、switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上？"><span class="toc-number">12.</span> <span class="toc-text">11、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12、用最有效率的方法计算-2-乘以-8？"><span class="toc-number">13.</span> <span class="toc-text">12、用最有效率的方法计算 2 乘以 8？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13、数组有没有-length-方法？String-有没有-length-方法？"><span class="toc-number">14.</span> <span class="toc-text">13、数组有没有 length()方法？String 有没有 length()方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14、在-Java-中，如何跳出当前的多重嵌套循环？"><span class="toc-number">15.</span> <span class="toc-text">14、在 Java 中，如何跳出当前的多重嵌套循环？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15、构造器（constructor）是否可被重写（override）？"><span class="toc-number">16.</span> <span class="toc-text">15、构造器（constructor）是否可被重写（override）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16、两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><span class="toc-number">17.</span> <span class="toc-text">16、两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17、是否可以继承-String-类？"><span class="toc-number">18.</span> <span class="toc-text">17、是否可以继承 String 类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"><span class="toc-number">19.</span> <span class="toc-text">18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19、String-和-StringBuilder、StringBuffer-的区别？"><span class="toc-number">20.</span> <span class="toc-text">19、String 和 StringBuilder、StringBuffer 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><span class="toc-number">21.</span> <span class="toc-text">20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21、描述一下-JVM-加载-class-文件的原理机制？"><span class="toc-number">22.</span> <span class="toc-text">21、描述一下 JVM 加载 class 文件的原理机制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22、char-型变量中能不能存贮一个中文汉字，为什么？"><span class="toc-number">23.</span> <span class="toc-text">22、char 型变量中能不能存贮一个中文汉字，为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23、抽象类（abstract-class）和接口（interface）有什么异同？"><span class="toc-number">24.</span> <span class="toc-text">23、抽象类（abstract class）和接口（interface）有什么异同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24、静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？"><span class="toc-number">25.</span> <span class="toc-text">24、静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25、Java-中会存在内存泄漏吗，请简单描述。"><span class="toc-number">26.</span> <span class="toc-text">25、Java 中会存在内存泄漏吗，请简单描述。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26、抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被-synchronized修饰？"><span class="toc-number">27.</span> <span class="toc-text">26、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被 synchronized修饰？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27、阐述静态变量和实例变量的区别。"><span class="toc-number">28.</span> <span class="toc-text">27、阐述静态变量和实例变量的区别。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><span class="toc-number">29.</span> <span class="toc-text">28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29、如何实现对象克隆？"><span class="toc-number">30.</span> <span class="toc-text">29、如何实现对象克隆？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30、GC-是什么？为什么要有-GC？"><span class="toc-number">31.</span> <span class="toc-text">30、GC 是什么？为什么要有 GC？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31、String-s-new-String-“xyz”-创建了几个字符串对象？"><span class="toc-number">32.</span> <span class="toc-text">31、String s &#x3D; new String(“xyz”);创建了几个字符串对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concreteclass）？"><span class="toc-number">33.</span> <span class="toc-text">32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concreteclass）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33、一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><span class="toc-number">34.</span> <span class="toc-text">33、一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34、Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？"><span class="toc-number">35.</span> <span class="toc-text">34、Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><span class="toc-number">36.</span> <span class="toc-text">35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36、Java-中的-final-关键字有哪些用法？"><span class="toc-number">37.</span> <span class="toc-text">36、Java 中的 final 关键字有哪些用法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37、指出下面程序的运行结果"><span class="toc-number">38.</span> <span class="toc-text">37、指出下面程序的运行结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38、数据类型之间的转换："><span class="toc-number">39.</span> <span class="toc-text">38、数据类型之间的转换：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39、如何实现字符串的反转及替换？"><span class="toc-number">40.</span> <span class="toc-text">39、如何实现字符串的反转及替换？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40、怎样将-GB2312-编码的字符串转换为-ISO-8859-1-编码的字符串？"><span class="toc-number">41.</span> <span class="toc-text">40、怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41、日期和时间："><span class="toc-number">42.</span> <span class="toc-text">41、日期和时间：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42、打印昨天的当前时刻。"><span class="toc-number">43.</span> <span class="toc-text">42、打印昨天的当前时刻。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43、比较一下-Java-和-JavaSciprt。"><span class="toc-number">44.</span> <span class="toc-text">43、比较一下 Java 和 JavaSciprt。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44、什么时候用断言（assert）？"><span class="toc-number">45.</span> <span class="toc-text">44、什么时候用断言（assert）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45、Error-和-Exception-有什么区别？"><span class="toc-number">46.</span> <span class="toc-text">45、Error 和 Exception 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46、try-里有一个-return-语句，那么紧跟在这个-try-后的finally-里的代码会不会被执行，什么时候被执行，在-return前还是后"><span class="toc-number">47.</span> <span class="toc-text">46、try{}里有一个 return 语句，那么紧跟在这个 try 后的finally{}里的代码会不会被执行，什么时候被执行，在 return前还是后?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47、Java-语言如何进行异常处理，关键字：throws、throw、try、catch、finally-分别如何使用？"><span class="toc-number">48.</span> <span class="toc-text">47、Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally 分别如何使用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48、运行时异常与受检异常有何异同？"><span class="toc-number">49.</span> <span class="toc-text">48、运行时异常与受检异常有何异同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49、列出一些你常见的运行时异常？"><span class="toc-number">50.</span> <span class="toc-text">49、列出一些你常见的运行时异常？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50、阐述-final、finally、finalize-的区别。"><span class="toc-number">51.</span> <span class="toc-text">50、阐述 final、finally、finalize 的区别。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51、类-ExampleA-继承-Exception，类-ExampleB-继承ExampleA。"><span class="toc-number">52.</span> <span class="toc-text">51、类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52、List、Set、Map-是否继承自-Collection-接口？"><span class="toc-number">53.</span> <span class="toc-text">52、List、Set、Map 是否继承自 Collection 接口？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53、阐述-ArrayList、Vector、LinkedList-的存储性能和特性。"><span class="toc-number">54.</span> <span class="toc-text">53、阐述 ArrayList、Vector、LinkedList 的存储性能和特性。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54、Collection-和-Collections-的区别？"><span class="toc-number">55.</span> <span class="toc-text">54、Collection 和 Collections 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55、List、Map、Set-三个接口存取元素时，各有什么特点？"><span class="toc-number">56.</span> <span class="toc-text">55、List、Map、Set 三个接口存取元素时，各有什么特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56、TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？"><span class="toc-number">57.</span> <span class="toc-text">56、TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57、Thread-类的-sleep-方法和对象的-wait-方法都可以让线程暂停执行，它们有什么区别"><span class="toc-number">58.</span> <span class="toc-text">57、Thread 类的 sleep()方法和对象的 wait()方法都可以让线程暂停执行，它们有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58、线程的-sleep-方法和-yield-方法有什么区别？"><span class="toc-number">59.</span> <span class="toc-text">58、线程的 sleep()方法和 yield()方法有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59、当一个线程进入一个对象的-synchronized-方法-A-之后，其它线程是否可进入此对象的-synchronized-方法-B？"><span class="toc-number">60.</span> <span class="toc-text">59、当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#60、请说出与线程同步以及线程调度相关的方法。"><span class="toc-number">61.</span> <span class="toc-text">60、请说出与线程同步以及线程调度相关的方法。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61、编写多线程程序有几种实现方式？"><span class="toc-number">62.</span> <span class="toc-text">61、编写多线程程序有几种实现方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62、synchronized-关键字的用法？"><span class="toc-number">63.</span> <span class="toc-text">62、synchronized 关键字的用法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63、举例说明同步和异步。"><span class="toc-number">64.</span> <span class="toc-text">63、举例说明同步和异步。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64、启动一个线程是调用-run-还是-start-方法？"><span class="toc-number">65.</span> <span class="toc-text">64、启动一个线程是调用 run()还是 start()方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65、什么是线程池（thread-pool）？"><span class="toc-number">66.</span> <span class="toc-text">65、什么是线程池（thread pool）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66、线程的基本状态以及状态之间的关系？"><span class="toc-number">67.</span> <span class="toc-text">66、线程的基本状态以及状态之间的关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67、简述-synchronized-和-java-util-concurrent-locks-Lock的异同？"><span class="toc-number">68.</span> <span class="toc-text">67、简述 synchronized 和 java.util.concurrent.locks.Lock的异同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68、Java-中如何实现序列化，有什么意义？"><span class="toc-number">69.</span> <span class="toc-text">68、Java 中如何实现序列化，有什么意义？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#69、Java-中有几种类型的流？"><span class="toc-number">70.</span> <span class="toc-text">69、Java 中有几种类型的流？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。"><span class="toc-number">71.</span> <span class="toc-text">70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#71、如何用-Java-代码列出一个目录下所有的文件？"><span class="toc-number">72.</span> <span class="toc-text">71、如何用 Java 代码列出一个目录下所有的文件？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72、用-Java-的套接字编程实现一个多线程的回显（echo）服务器。"><span class="toc-number">73.</span> <span class="toc-text">72、用 Java 的套接字编程实现一个多线程的回显（echo）服务器。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73、XML-文档定义有几种形式？它们之间有何本质区别？解析XML-文档有哪几种方式？"><span class="toc-number">74.</span> <span class="toc-text">73、XML 文档定义有几种形式？它们之间有何本质区别？解析XML 文档有哪几种方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74、你在项目中哪些地方用到了-XML？"><span class="toc-number">75.</span> <span class="toc-text">74、你在项目中哪些地方用到了 XML？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75、阐述-JDBC-操作数据库的步骤。"><span class="toc-number">76.</span> <span class="toc-text">75、阐述 JDBC 操作数据库的步骤。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76、Statement-和-PreparedStatement-有什么区别？哪个性能更好？"><span class="toc-number">77.</span> <span class="toc-text">76、Statement 和 PreparedStatement 有什么区别？哪个性能更好？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#77、使用-JDBC-操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？"><span class="toc-number">78.</span> <span class="toc-text">77、使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78、在进行数据库编程时，连接池有什么作用？"><span class="toc-number">79.</span> <span class="toc-text">78、在进行数据库编程时，连接池有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#79、什么是-DAO-模式？"><span class="toc-number">80.</span> <span class="toc-text">79、什么是 DAO 模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#80、事务的-ACID-是指什么？"><span class="toc-number">81.</span> <span class="toc-text">80、事务的 ACID 是指什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#81、JDBC-中如何进行事务处理？"><span class="toc-number">82.</span> <span class="toc-text">81、JDBC 中如何进行事务处理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82、JDBC-能否处理-Blob-和-Clob？"><span class="toc-number">83.</span> <span class="toc-text">82、JDBC 能否处理 Blob 和 Clob？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83、简述正则表达式及其用途。"><span class="toc-number">84.</span> <span class="toc-text">83、简述正则表达式及其用途。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84、Java-中是如何支持正则表达式操作的？"><span class="toc-number">85.</span> <span class="toc-text">84、Java 中是如何支持正则表达式操作的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#85、获得一个类的类对象有哪些方式？"><span class="toc-number">86.</span> <span class="toc-text">85、获得一个类的类对象有哪些方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#86、如何通过反射创建对象？"><span class="toc-number">87.</span> <span class="toc-text">86、如何通过反射创建对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#87、如何通过反射获取和设置对象私有字段的值？"><span class="toc-number">88.</span> <span class="toc-text">87、如何通过反射获取和设置对象私有字段的值？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#88、如何通过反射调用对象的方法？"><span class="toc-number">89.</span> <span class="toc-text">88、如何通过反射调用对象的方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#89、简述一下面向对象的”六原则一法则”。"><span class="toc-number">90.</span> <span class="toc-text">89、简述一下面向对象的”六原则一法则”。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#90、简述一下你了解的设计模式。"><span class="toc-number">91.</span> <span class="toc-text">90、简述一下你了解的设计模式。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#91、用-Java-写一个单例类。"><span class="toc-number">92.</span> <span class="toc-text">91、用 Java 写一个单例类。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92、什么是-UML？"><span class="toc-number">93.</span> <span class="toc-text">92、什么是 UML？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#93、UML-中有哪些常用的图？"><span class="toc-number">94.</span> <span class="toc-text">93、UML 中有哪些常用的图？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94、用-Java-写一个冒泡排序。"><span class="toc-number">95.</span> <span class="toc-text">94、用 Java 写一个冒泡排序。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#95、用-Java-写一个折半查找。"><span class="toc-number">96.</span> <span class="toc-text">95、用 Java 写一个折半查找。</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(http://cdn.panyucable.cn/zysheep/1927x1080.jfif)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">三月三</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-bug" aria-hidden="true"></i><span> 编程路线</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/java/"><i class="fa-fw fa fa-coffee"></i><span> Java</span></a></li><li><a class="site-page" href="/python/"><i class="fa-fw fa fa-binoculars"></i><span> Python</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-folder-open" aria-hidden="true"></i><span> 面试宝典</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/interview/"><i class="fa-fw fa fa-file-text-o"></i><span> Java面试题</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 我的生活</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-picture-o"></i><span> Gallery</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Java面试题(一)</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-03-03 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-03-03</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-29 17:37:55"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-29</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/">面试宝典</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/Java%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%B8%80/">Java面试题(一)</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">28.9k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 99 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/03/03/interview/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98(%E4%B8%80)/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="Java面试题（一）"><a href="#Java面试题（一）" class="headerlink" title="Java面试题（一）"></a>Java面试题（一）</h2><p>1、面向对象的特征有哪些方面？</p>
<p>2、访问修饰符 public,private,protected,以及不写（默认）时的区别？</p>
<p>3、String 是最基本的数据类型吗？</p>
<p>4、float f=3.4;是否正确？</p>
<p>5、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？</p>
<p>6、Java 有没有 goto？</p>
<p>7、int 和 Integer 有什么区别？</p>
<p>8、&amp;和&amp;&amp;的区别？</p>
<p>9、解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。</p>
<p>10、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？</p>
<p>11、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？</p>
<p>12、用最有效率的方法计算 2 乘以 8？</p>
<p>13、数组有没有 length()方法？String 有没有 length()方法？</p>
<p>14、在 Java 中，如何跳出当前的多重嵌套循环？</p>
<p>15、构造器（constructor）是否可被重写（override）？</p>
<p>16、两个对象值相同(x.equals(y) == true)，但却可有不同的 hashcode，这句话对不对？</p>
<p>17、是否可以继承 String 类？</p>
<p>18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</p>
<p>19、String 和 StringBuilder、StringBuffer 的区别？</p>
<p>20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</p>
<p>21、描述一下 JVM 加载 class 文件的原理机制？</p>
<p>22、char 型变量中能不能存贮一个中文汉字，为什么？</p>
<p>23、抽象类（abstract class）和接口（interface）有什么异同？</p>
<p>24、静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</p>
<p>25、Java 中会存在内存泄漏吗，请简单描述。</p>
<p>26、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被 synchronized 修饰？</p>
<p>27、阐述静态变量和实例变量的区别。</p>
<p>28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</p>
<p>29、如何实现对象克隆？</p>
<p>30、GC 是什么？为什么要有 GC？</p>
<p>31、String s = new String(“xyz”);创建了几个字符串对象？</p>
<p>32 、 接 口 是 否 可 继 承 （ extends ） 接 口 ？ 抽 象 类 是 否 可 实 现（implements）接口？抽象类是否可继承具体类（concrete class）？</p>
<p>33、一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</p>
<p>34、Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</p>
<p>35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</p>
<p>36、Java 中的 final 关键字有哪些用法？</p>
<p>37、指出下面程序的运行结果</p>
<p>38、数据类型之间的转换：</p>
<p>39、如何实现字符串的反转及替换？</p>
<p>40、怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串？</p>
<p>41、日期和时间：</p>
<p>42、打印昨天的当前时刻。</p>
<p>43、比较一下 Java 和 JavaSciprt。</p>
<p>44、什么时候用断言（assert）？</p>
<p>45、Error 和 Exception 有什么区别？</p>
<p>46、try{}里有一个 return 语句，那么紧跟在这个 try 后的 finally{}里的代码会不会被执行，什么时候被执行，在 return 前还是后?</p>
<p>47、Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally 分别如何使用？</p>
<p>48、运行时异常与受检异常有何异同？</p>
<p>49、列出一些你常见的运行时异常？</p>
<p>50、阐述 final、finally、finalize 的区别。</p>
<p>51、类 ExampleA 继承 Exception，类 ExampleB 继承 ExampleA。</p>
<p>52、List、Set、Map 是否继承自 Collection 接口？</p>
<p>53、阐述 ArrayList、Vector、LinkedList 的存储性能和特性。</p>
<p>54、Collection 和 Collections 的区别？</p>
<p>55、List、Map、Set 三个接口存取元素时，各有什么特点？</p>
<p>56、TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</p>
<p>57、Thread 类的 sleep()方法和对象的 wait()方法都可以让线程暂停执行，它们有什么区别?</p>
<p>58、线程的 sleep()方法和 yield()方法有什么区别？</p>
<p>59、当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象 synchronized 方法 B？</p>
<p>60、请说出与线程同步以及线程调度相关的方法。</p>
<p>61、编写多线程程序有几种实现方式？</p>
<p>62、synchronized 关键字的用法？</p>
<p>63、举例说明同步和异步。</p>
<p>64、启动一个线程是调用 run()还是 start()方法？</p>
<p>65、什么是线程池（thread pool）？</p>
<p>66、线程的基本状态以及状态之间的关系？</p>
<p>67、简述 synchronized 和 java.util.concurrent.locks.Lock 的异同？</p>
<p>68、Java 中如何实现序列化，有什么意义？</p>
<p>69、Java 中有几种类型的流？</p>
<p>70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。</p>
<p>71、如何用 Java 代码列出一个目录下所有的文件？</p>
<p>72、用 Java 的套接字编程实现一个多线程的回显（echo）服务器。</p>
<p>73、XML 文档定义有几种形式？它们之间有何本质区别？解析 XML文档有哪几种方式？</p>
<p>74、你在项目中哪些地方用到了 XML？</p>
<p>75、阐述 JDBC 操作数据库的步骤。</p>
<p>76、Statement 和 PreparedStatement 有什么区别？哪个性能更好？</p>
<p>77、使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？</p>
<p>78、在进行数据库编程时，连接池有什么作用？</p>
<p>79、什么是 DAO 模式？</p>
<p>80、事务的 ACID 是指什么？</p>
<p>82、JDBC 能否处理 Blob 和 Clob？</p>
<p>83、简述正则表达式及其用途。</p>
<p>84、Java 中是如何支持正则表达式操作的？</p>
<p>85、获得一个类的类对象有哪些方式？</p>
<p>88、如何通过反射调用对象的方法？</p>
<p>90、简述一下你了解的设计模式。</p>
<p>91、用 Java 写一个单例类。</p>
<p>92、什么是 UML？</p>
<p>93、UML 中有哪些常用的图？</p>
<p>95、用 Java 写一个折半查找。</p>
<h2 id="1、面向对象的特征有哪些方面？"><a href="#1、面向对象的特征有哪些方面？" class="headerlink" title="1、面向对象的特征有哪些方面？"></a>1、面向对象的特征有哪些方面？</h2><p><strong>面向对象的特征主要有以下几个方面：</strong></p>
<p><strong>抽象：</strong>抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p>
<p><strong>继承：</strong>继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java 与模式》或《设计模式精解》中关于桥梁模式的部分）。</p>
<p><strong>封装：</strong>通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。</p>
<p><strong>多态性：</strong>多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当 A 系统访问 B 系统提供的服务时，B系统有多种提供服务的方式，但一切对 A 系统来说都是透明的（就像电动剃须刀是 A 系统，它的供电系统是 B 系统，B 系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A 系统只会通过 B 类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：</p>
<p>1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）； </p>
<p>2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</p>
<h2 id="2、访问修饰符-public-private-protected-以及不写（默认）时的区别？"><a href="#2、访问修饰符-public-private-protected-以及不写（默认）时的区别？" class="headerlink" title="2、访问修饰符 public,private,protected,以及不写（默认）时的区别？"></a>2、访问修饰符 public,private,protected,以及不写（默认）时的区别？</h2><p>修饰符 当前类 同 包 子 类 其他包</p>
<p><img src="http://cdn.panyucable.cn/zysheep/16ed5486fab6aaa5.jpg" alt=""></p>
<p>类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java 中，外部类的修饰符只能是 public 或默认，类的成员（包括内部类）的修饰符可以是以上四种。</p>
<h2 id="3、String-是最基本的数据类型吗？"><a href="#3、String-是最基本的数据类型吗？" class="headerlink" title="3、String 是最基本的数据类型吗？"></a>3、String 是最基本的数据类型吗？</h2><p>不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。</p>
<h2 id="4、float-f-3-4-是否正确？"><a href="#4、float-f-3-4-是否正确？" class="headerlink" title="4、float f=3.4;是否正确？"></a>4、float f=3.4;是否正确？</h2><p>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;。</p>
<h2 id="5、short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？"><a href="#5、short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？" class="headerlink" title="5、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？"></a>5、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？</h2><p>对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。</p>
<h2 id="6、Java-有没有-goto？"><a href="#6、Java-有没有-goto？" class="headerlink" title="6、Java 有没有 goto？"></a>6、Java 有没有 goto？</h2><p>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。（根据 James Gosling（Java 之父）编写的《The Java Programming Language》一书的附录中给出了一个 Java 关键字列表，其中有goto 和 const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉 C 语言的程序员都知道，在系统类库中使用过的有特殊意义的但词或单词的组合都被视为保留字）</p>
<h2 id="7、int-和-Integer-有什么区别？"><a href="#7、int-和-Integer-有什么区别？" class="headerlink" title="7、int 和 Integer 有什么区别？"></a>7、int 和 Integer 有什么区别？</h2><p>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p>
<p>Java 为每个原始类型提供了包装类型：</p>
<p>原始类型: boolean，char，byte，short，int，long，float，double</p>
<p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class AutoUnboxingTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Integer a &#x3D; new Integer(3);</span><br><span class="line">		Integer b &#x3D; 3;</span><br><span class="line">		&#x2F;&#x2F; 将 3 自动装箱成 Integer 类型</span><br><span class="line">		int c &#x3D; 3;</span><br><span class="line">		System.out.println(a &#x3D;&#x3D; b);</span><br><span class="line">		&#x2F;&#x2F; false 两个引用没有引用同一对</span><br><span class="line">		象</span><br><span class="line">		System.out.println(a &#x3D;&#x3D; c);</span><br><span class="line">		&#x2F;&#x2F; true a 自动拆箱成 int 类型再和 c</span><br><span class="line">		比较</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test03 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Integer f1 &#x3D; 100, f2 &#x3D; 100, f3 &#x3D; 150, f4 &#x3D; 150;</span><br><span class="line">		System.out.println(f1 &#x3D;&#x3D; f2);</span><br><span class="line">		System.out.println(f3 &#x3D;&#x3D; f4);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不明就里很容易认为两个输出要么都是 true 要么都是 false。首先需要注意的是 f1、f2、f3、f4 四个变量都是 Integer 对象引用，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个 Integer 对象赋一个 int 值的时候，会调用 Integer 类的静态方法 valueOf，如果看 valueOf 的源代码就知道发生了什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">	if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)</span><br><span class="line">	return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">	return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IntegerCache 是 Integer 的内部类，其代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Cache to support the object identity semantics of autoboxing for</span><br><span class="line">values between</span><br><span class="line">* -128 and 127 (inclusive) as required by JLS.</span><br><span class="line">*</span><br><span class="line">* The cache is initialized on first usage. The size of the cache</span><br><span class="line">* may be controlled by the &#123;@code -XX:AutoBoxCacheMax&#x3D;&lt;size&gt;&#125;</span><br><span class="line">option.</span><br><span class="line">* During VM initialization, java.lang.Integer.IntegerCache.high</span><br><span class="line">property</span><br><span class="line">* may be set and saved in the private system properties in the</span><br><span class="line">* sun.misc.VM class.</span><br><span class="line">*&#x2F;</span><br><span class="line">private static class IntegerCache &#123;</span><br><span class="line">	static final int low &#x3D; -128;</span><br><span class="line">	static final int high;</span><br><span class="line">	static final Integer cache[];</span><br><span class="line">	static &#123;</span><br><span class="line">		&#x2F;&#x2F; high value may be configured by property</span><br><span class="line">		int h &#x3D; 127;</span><br><span class="line">		String integerCacheHighPropValue &#x3D;</span><br><span class="line">		sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class="line">		if (integerCacheHighPropValue !&#x3D; null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				int i &#x3D; parseint(integerCacheHighPropValue);</span><br><span class="line">				i &#x3D; Math.max(i, 127);</span><br><span class="line">				&#x2F;&#x2F; Maximum array size is Integer.MAX_VALUE</span><br><span class="line">				h &#x3D; Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">			&#125;</span><br><span class="line">			catch( NumberFormatException nfe) &#123;</span><br><span class="line">				&#x2F;&#x2F; If the property cannot be parsed into an int,</span><br><span class="line">				ignore it.</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		high &#x3D; h;</span><br><span class="line">		cache &#x3D; new Integer[(high - low) + 1];</span><br><span class="line">		int j &#x3D; low;</span><br><span class="line">		for (int k &#x3D; 0; k &lt; cache.length; k++)</span><br><span class="line">		cache[k] &#x3D; new Integer(j++);</span><br><span class="line">		&#x2F;&#x2F; range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class="line">		assert IntegerCache.high &gt;&#x3D; 127;</span><br><span class="line">	&#125;</span><br><span class="line">	private IntegerCache() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的说，如果整型字面量的值在-128 到 127 之间，那么不会 new 新的 Integer对象，而是直接引用常量池中的 Integer 对象，所以上面的面试题中 f1f4 的结果是 false。</p>
<p>提醒：越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。 </p>
<h2 id="8、-amp-和-amp-amp-的区别？"><a href="#8、-amp-和-amp-amp-的区别？" class="headerlink" title="8、&amp;和&amp;&amp;的区别？"></a>8、&amp;和&amp;&amp;的区别？</h2><p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是 null 而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的 equals 比较，否则会生 NullPointerException 异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p>
<h2 id="9、解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法。"><a href="#9、解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法。" class="headerlink" title="9、解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。"></a>9、解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。</h2><p>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用 JVM 中的栈空间；而通过 new 关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为 Eden、Survivor（又可分为 From Survivor 和 To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被 JVM 加载的类信息、常量、静态变量、JIT 编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的 100、”hello”和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过 JVM的启动参数来进行调整，栈空间用光了会引发 StackOverflowError，而堆和常量池空间不足则会引发 OutOfMemoryError。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; new String(&quot;hello&quot;);</span><br></pre></td></tr></table></figure>

<p>上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而”hello”这个字面量是放在方法区的。</p>
<p>补充 1：较新版本的 Java（从 Java 6 的某个更新开始）中，由于 JIT 编译器的发展和”逃逸分析”技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象一定分配在堆上这件事情已经变得不那么绝对了。</p>
<p>补充 2：运行时常量池相当于 Class 文件常量池具有动态性，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String类的 intern()方法就是这样的。</p>
<p>看看下面代码的执行结果是什么并且比较一下 Java 7 以前和以后的运行结果是否一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 &#x3D; new StringBuilder(&quot;go&quot;)</span><br><span class="line">.append(&quot;od&quot;).toString();</span><br><span class="line">System.out.println(s1.intern() &#x3D;&#x3D; s1);</span><br><span class="line">String s2 &#x3D; new StringBuilder(&quot;ja&quot;)</span><br><span class="line">.append(&quot;va&quot;).toString();</span><br><span class="line">System.out.println(s2.intern() &#x3D;&#x3D; s2);</span><br></pre></td></tr></table></figure>

<h2 id="10、Math-round-11-5-等于多少？Math-round-11-5-等于多少？"><a href="#10、Math-round-11-5-等于多少？Math-round-11-5-等于多少？" class="headerlink" title="10、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？"></a>10、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？</h2><p>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。</p>
<h2 id="11、switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上？"><a href="#11、switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上？" class="headerlink" title="11、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？"></a>11、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？</h2><p>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p>
<h2 id="12、用最有效率的方法计算-2-乘以-8？"><a href="#12、用最有效率的方法计算-2-乘以-8？" class="headerlink" title="12、用最有效率的方法计算 2 乘以 8？"></a>12、用最有效率的方法计算 2 乘以 8？</h2><p>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。</p>
<p><strong>补充：</strong>我们为编写的类重写 hashCode 方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择 31 这个数？前两个问题的答案你可以自己百度一下，选择 31 是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num 等价于(num &lt;&lt; 5) - num，左移 5位相当于乘以 2 的 5 次方再减去自身就相当于乘以 31，现在的 VM 都能自动完成这个优化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class PhoneNumber &#123;</span><br><span class="line">	private int areaCode;</span><br><span class="line">	private String prefix;</span><br><span class="line">	private String lineNumber;</span><br><span class="line">	@Override</span><br><span class="line">	public int hashCode() &#123;</span><br><span class="line">		final int prime &#x3D; 31;</span><br><span class="line">		int result &#x3D; 1;</span><br><span class="line">		result &#x3D; prime * result + areaCode;</span><br><span class="line">		result &#x3D; prime * result</span><br><span class="line">		+ ((lineNumber &#x3D;&#x3D; null) ? 0 : lineNumber.hashCode());</span><br><span class="line">		result &#x3D; prime * result + ((prefix &#x3D;&#x3D; null) ? 0 : prefix.hashCode());</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public Boolean equals(Object obj) &#123;</span><br><span class="line">		if (this &#x3D;&#x3D; obj)</span><br><span class="line">		return true;</span><br><span class="line">		if (obj &#x3D;&#x3D; null)</span><br><span class="line">		return false;</span><br><span class="line">		if (getClass() !&#x3D; obj.getClass())</span><br><span class="line">		return false;</span><br><span class="line">		PhoneNumber other &#x3D; (PhoneNumber) obj;</span><br><span class="line">		if (areaCode !&#x3D; other.areaCode)</span><br><span class="line">		return false;</span><br><span class="line">		if (lineNumber &#x3D;&#x3D; null) &#123;</span><br><span class="line">			if (other.lineNumber !&#x3D; null)</span><br><span class="line">			return false;</span><br><span class="line">		&#125; else if (!lineNumber.equals(other.lineNumber))</span><br><span class="line">		return false;</span><br><span class="line">		if (prefix &#x3D;&#x3D; null) &#123;</span><br><span class="line">			if (other.prefix !&#x3D; null)</span><br><span class="line">			return false;</span><br><span class="line">		&#125; else if (!prefix.equals(other.prefix))</span><br><span class="line">		return false;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13、数组有没有-length-方法？String-有没有-length-方法？"><a href="#13、数组有没有-length-方法？String-有没有-length-方法？" class="headerlink" title="13、数组有没有 length()方法？String 有没有 length()方法？"></a>13、数组有没有 length()方法？String 有没有 length()方法？</h2><p>数组没有 length()方法 ，有 length 的属性。String 有 length()方法。JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。</p>
<h2 id="14、在-Java-中，如何跳出当前的多重嵌套循环？"><a href="#14、在-Java-中，如何跳出当前的多重嵌套循环？" class="headerlink" title="14、在 Java 中，如何跳出当前的多重嵌套循环？"></a>14、在 Java 中，如何跳出当前的多重嵌套循环？</h2><p>在最外层循环前加一个标记如 A，然后用 break A;可以跳出多重循环。（Java 中支持带标签的 break 和 continue 语句，作用有点类似于 C 和 C++中的 goto 语句，但是就像要避免使用 goto 一样，应该避免使用带标签的 break 和 continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好）</p>
<h2 id="15、构造器（constructor）是否可被重写（override）？"><a href="#15、构造器（constructor）是否可被重写（override）？" class="headerlink" title="15、构造器（constructor）是否可被重写（override）？"></a>15、构造器（constructor）是否可被重写（override）？</h2><p>构造器不能被继承，因此不能被重写，但可以被重载。</p>
<h2 id="16、两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#16、两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="16、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？"></a>16、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</h2><p>不对，如果两个对象 x 和 y 满足 x.equals(y) == true，它们的哈希码（hash code）应当相同。Java 对于 eqauls 方法和 hashCode 方法是这样规定的：</p>
<p>(1)如果两个对象相同（equals 方法返回 true），那么它们的 hashCode 值一定要相同；</p>
<p>(2)如果两个对象的 hashCode 相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在 Set 集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。</p>
<p><strong>补充：</strong>关于 equals 和 hashCode 方法，很多 Java 程序都知道，但很多人也就是仅仅知道而已，在 Joshua Bloch 的大作《Effective Java》（很多软件公司，《Effective Java》、《Java 编程思想》以及《重构：改善既有代码质量》是 Java程序员必看书籍，如果你还没看过，那就赶紧去亚马逊买一本吧）中是这样介绍equals 方法的：首先 equals 方法必须满足自反性（x.equals(x)必须返回 true）、</p>
<p>对称性（x.equals(y)返回 true 时，y.equals(x)也必须返回 true）、传递性（x.equals(y)和 y.equals(z)都返回 true 时，x.equals(z)也必须返回 true）和一致性（当 x 和 y 引用的对象信息没有被修改时，多次调用 x.equals(y)应该得到同样的返回值），而且对于任何非 null 值的引用 x，x.equals(null)必须返回 false。</p>
<p>实现高质量的 equals 方法的诀窍包括：</p>
<p>(1) 使用==操作符检查”参数是否为这个对象的引用”；</p>
<p>(2) 使用 instanceof 操作符检查”参数是否为正确的类型”；</p>
<p>(3) 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；</p>
<p>(4) 编写完 equals方法后，问自己它是否满足对称性、传递性、一致性；</p>
<p>(5) 重写 equals 时总是要重写 hashCode；</p>
<p>(6)  不要将 equals 方法参数中的 Object 对象替换为其他的类型，在重写时不要忘掉@Override 注解。</p>
<h2 id="17、是否可以继承-String-类？"><a href="#17、是否可以继承-String-类？" class="headerlink" title="17、是否可以继承 String 类？"></a>17、是否可以继承 String 类？</h2><p>String 类是 final 类，不可以被继承。</p>
<p>补充：继承 String 本身就是一个错误的行为，对 String 类型最好的重用方式是关联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。</p>
<h2 id="18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"><a href="#18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？" class="headerlink" title="18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"></a>18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</h2><p>是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。C++和 C#中可以通过传引用或传输出参数来改变传入的参数的值。在 C#中可以编写如下所示的代码，但是在 Java 中却做不到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace CS01 &#123;</span><br><span class="line">	class Program &#123;</span><br><span class="line">		public static void swap(ref int x, ref int y) &#123;</span><br><span class="line">			int temp &#x3D; x;</span><br><span class="line">			x &#x3D; y;</span><br><span class="line">			y &#x3D; temp;</span><br><span class="line">		&#125;</span><br><span class="line">		public static void Main (string[] args) &#123;</span><br><span class="line">			int a &#x3D; 5, b &#x3D; 10;</span><br><span class="line">			swap (ref a, ref b);</span><br><span class="line">			&#x2F;&#x2F; a &#x3D; 10, b &#x3D; 5;</span><br><span class="line">			第 225 页 共 485 页</span><br><span class="line">			Console.WriteLine (&quot;a &#x3D; &#123;0&#125;, b &#x3D; &#123;1&#125;&quot;, a, b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>Java 中没有传引用实在是非常的不方便，这一点在 Java 8 中仍然没有得到改进，正是如此在 Java 编写的代码中才会出现大量的 Wrapper 类（将需要通过方法调用修改的引用置于一个 Wrapper 类中，再将 Wrapper 对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从 C 和 C++转型为 Java 程序员的开发者无法容忍。</p>
<h2 id="19、String-和-StringBuilder、StringBuffer-的区别？"><a href="#19、String-和-StringBuilder、StringBuffer-的区别？" class="headerlink" title="19、String 和 StringBuilder、StringBuffer 的区别？"></a>19、String 和 StringBuilder、StringBuffer 的区别？</h2><p>Java 平台提供了两种类型的字符串：String 和 StringBuffer/StringBuilder，它们可以储存和操作字符串。其中 String 是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。而 StringBuffer/StringBuilder 类表示的字符串对象可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized 修饰，因此它的效率也比 StringBuffer 要高。</p>
<p>面试题 1 - 什么情况下用+运算符进行字符串连接比调用</p>
<p>StringBuffer/StringBuilder 对象的 append 方法连接字符串性能更好？</p>
<p>面试题 2 - 请说出下面程序的输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class StringEqualTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String s1 &#x3D; &quot;Programming&quot;;</span><br><span class="line">		String s2 &#x3D; new String(&quot;Programming&quot;);</span><br><span class="line">		String s3 &#x3D; &quot;Program&quot;;</span><br><span class="line">		String s4 &#x3D; &quot;ming&quot;;</span><br><span class="line">		String s5 &#x3D; &quot;Program&quot; + &quot;ming&quot;;</span><br><span class="line">		String s6 &#x3D; s3 + s4;</span><br><span class="line">		System.out.println(s1 &#x3D;&#x3D; s2);</span><br><span class="line">		System.out.println(s1 &#x3D;&#x3D; s5);</span><br><span class="line">		System.out.println(s1 &#x3D;&#x3D; s6);</span><br><span class="line">		System.out.println(s1 &#x3D;&#x3D; s6.intern());</span><br><span class="line">		System.out.println(s2 &#x3D;&#x3D; s2.intern());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充：</strong>解答上面的面试题需要清除两点：</p>
<p>(1)String 对象的 intern 方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与 String 对象的 equals 结果是 true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；</p>
<p>(2)字符串的+操作其本质是创建了 StringBuilder 对象进行 append 操作，然后将拼接后的 StringBuilder 对象用toString 方法处理成 String 对象，这一点可以用 javap -c StringEqualTest.class命令获得 class 文件对应的 JVM 字节码指令就可以看出来。</p>
<h2 id="20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h2><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</p>
<h2 id="21、描述一下-JVM-加载-class-文件的原理机制？"><a href="#21、描述一下-JVM-加载-class-文件的原理机制？" class="headerlink" title="21、描述一下 JVM 加载 class 文件的原理机制？"></a>21、描述一下 JVM 加载 class 文件的原理机制？</h2><p>JVM 中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java 中的类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。</p>
<p>由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class 文件中的数据读入到内存中，通常是创建一个字节数组读入.class 文件，然后产生与所加载类对应的 Class 对象。加载完成后，Class 对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后 JVM 对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。</p>
<p>类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader 的子类）。从 Java 2（JDK 1.2）开始，从 Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM 更好的保证了 Java 平台的安全性，在该机制中，JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM 不会向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类加载器的说明：</p>
<p>（1） Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）；</p>
<p>（2） Extension：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap；</p>
<p>（3） System：又叫应用类加载器，其父类是 Extension。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器。</p>
<h2 id="22、char-型变量中能不能存贮一个中文汉字，为什么？"><a href="#22、char-型变量中能不能存贮一个中文汉字，为什么？" class="headerlink" title="22、char 型变量中能不能存贮一个中文汉字，为什么？"></a>22、char 型变量中能不能存贮一个中文汉字，为什么？</h2><p>char 类型可以存储一个中文汉字，因为 Java 中使用的编码是 Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个 char 类型占 2 个字节（16 比特），所以放一个中文是没问题的。</p>
<p>补充：使用 Unicode 意味着字符在 JVM 内部和外部有不同的表现形式，在 JVM内部都是 Unicode，当这个字符被从 JVM 内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以 Java 中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如 InputStreamReader 和 OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于 C 程序员来说，要完成这样的编码转换恐怕要依赖于 union（联合体/共用体）共享内存的特征来实现了。</p>
<h2 id="23、抽象类（abstract-class）和接口（interface）有什么异同？"><a href="#23、抽象类（abstract-class）和接口（interface）有什么异同？" class="headerlink" title="23、抽象类（abstract class）和接口（interface）有什么异同？"></a>23、抽象类（abstract class）和接口（interface）有什么异同？</h2><p>抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是 private、默认、protected、public 的，而接口中的成员全都是 public 的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。</p>
<h2 id="24、静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？"><a href="#24、静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？" class="headerlink" title="24、静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？"></a>24、静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</h2><p>Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 扑克类（一副扑克）</span><br><span class="line">* @author 骆昊</span><br><span class="line">*</span><br><span class="line">*&#x2F;</span><br><span class="line">public class Poker &#123;</span><br><span class="line">	private static String[] suites &#x3D; &#123;&quot;黑桃&quot;, &quot;红桃&quot;, &quot;草花&quot;, &quot;方块&quot;&#125;;</span><br><span class="line">	private static int[] faces &#x3D; &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13&#125;;</span><br><span class="line">	private Card[] cards;</span><br><span class="line">	&#x2F;**</span><br><span class="line">* 构造器</span><br><span class="line">*</span><br><span class="line">*&#x2F;</span><br><span class="line">	public Poker() &#123;</span><br><span class="line">		cards &#x3D; new Card[52];</span><br><span class="line">		for (int i &#x3D; 0; i &lt; suites.length; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; faces.length; j++) &#123;</span><br><span class="line">				cards[i * 13 + j] &#x3D; new Card(suites[i], faces[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;**</span><br><span class="line">* 洗牌 （随机乱序）</span><br><span class="line">*</span><br><span class="line">*&#x2F;</span><br><span class="line">	public void shuffle() &#123;</span><br><span class="line">		for (int i &#x3D; 0, len &#x3D; cards.length; i &lt; len; i++) &#123;</span><br><span class="line">			int index &#x3D; (int) (Math.random() * len);</span><br><span class="line">			Card temp &#x3D; cards[index];</span><br><span class="line">			cards[index] &#x3D; cards[i];</span><br><span class="line">			cards[i] &#x3D; temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;**</span><br><span class="line">* 发牌</span><br><span class="line">* @param index 发牌的位置</span><br><span class="line">*</span><br><span class="line">*&#x2F;</span><br><span class="line">	public Card deal(int index) &#123;</span><br><span class="line">		return cards[index];</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;**</span><br><span class="line">* 卡片类（一张扑克）</span><br><span class="line">* [内部类]</span><br><span class="line">* @author 骆昊</span><br><span class="line">*</span><br><span class="line">*&#x2F;</span><br><span class="line">	public class Card &#123;</span><br><span class="line">		private String suite;</span><br><span class="line">		&#x2F;&#x2F; 花色</span><br><span class="line">		private int face;</span><br><span class="line">		&#x2F;&#x2F; 点数</span><br><span class="line">		public Card(String suite, int face) &#123;</span><br><span class="line">			this.suite &#x3D; suite;</span><br><span class="line">			this.face &#x3D; face;</span><br><span class="line">		&#125;</span><br><span class="line">		@Override</span><br><span class="line">		public String toString() &#123;</span><br><span class="line">			String faceStr &#x3D; &quot;&quot;;</span><br><span class="line">			switch(face) &#123;</span><br><span class="line">				case 1: faceStr &#x3D; &quot;A&quot;;</span><br><span class="line">				break;</span><br><span class="line">				case 11: faceStr &#x3D; &quot;J&quot;;</span><br><span class="line">				break;</span><br><span class="line">				case 12: faceStr &#x3D; &quot;Q&quot;;</span><br><span class="line">				break;</span><br><span class="line">				case 13: faceStr &#x3D; &quot;K&quot;;</span><br><span class="line">				break;</span><br><span class="line">				default: faceStr &#x3D; String.valueOf(face);</span><br><span class="line">			&#125;</span><br><span class="line">			return suite + faceStr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">测试代码：</span><br><span class="line">class PokerTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Poker poker &#x3D; new Poker();</span><br><span class="line">		poker.shuffle();</span><br><span class="line">		&#x2F;&#x2F; 洗牌</span><br><span class="line">		Poker.Card c1 &#x3D; poker.deal(0);</span><br><span class="line">		&#x2F;&#x2F; 发第一张牌</span><br><span class="line">		&#x2F;&#x2F; 对于非静态内部类 Card</span><br><span class="line">		&#x2F;&#x2F; 只有通过其外部类 Poker 对象才能创建 Card 对象</span><br><span class="line">		Poker.Card c2 &#x3D; poker.new Card(&quot;红心&quot;, 1);</span><br><span class="line">		&#x2F;&#x2F; 自己创建一张牌</span><br><span class="line">		System.out.println(c1);</span><br><span class="line">		&#x2F;&#x2F; 洗牌后的第一张</span><br><span class="line">		System.out.println(c2);</span><br><span class="line">		&#x2F;&#x2F; 打印: 红心 A</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面试题 - 下面的代码哪些地方会产生编译错误？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line">	class Inner &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void foo() &#123;</span><br><span class="line">		new Inner();</span><br><span class="line">	&#125;</span><br><span class="line">	public void bar() &#123;</span><br><span class="line">		new Inner();</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new Inner();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>Java 中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中 foo和 main 方法都是静态方法，静态方法中没有 this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Outer().new Inner();</span><br></pre></td></tr></table></figure>

<h2 id="25、Java-中会存在内存泄漏吗，请简单描述。"><a href="#25、Java-中会存在内存泄漏吗，请简单描述。" class="headerlink" title="25、Java 中会存在内存泄漏吗，请简单描述。"></a>25、Java 中会存在内存泄漏吗，请简单描述。</h2><p>理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是 Java 被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被 GC 回收，因此也会导致内存泄露的发生。例如Hibernate 的 Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。下面例子中的代码也会导致内存泄露。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.EmptyStackException;</span><br><span class="line">public class MyStack&lt;T&gt; &#123;</span><br><span class="line">	private T[] elements;</span><br><span class="line">	private int size &#x3D; 0;</span><br><span class="line">	private static final int INIT_CAPACITY &#x3D; 16;</span><br><span class="line">	public MyStack() &#123;</span><br><span class="line">		elements &#x3D; (T[]) new Object[INIT_CAPACITY];</span><br><span class="line">	&#125;</span><br><span class="line">	public void push(T elem) &#123;</span><br><span class="line">		ensureCapacity();</span><br><span class="line">		elements[size++] &#x3D; elem;</span><br><span class="line">	&#125;</span><br><span class="line">	public T pop() &#123;</span><br><span class="line">		if(size &#x3D;&#x3D; 0)</span><br><span class="line">		throw new EmptyStackException();</span><br><span class="line">		return elements[--size];</span><br><span class="line">	&#125;</span><br><span class="line">	private void ensureCapacity() &#123;</span><br><span class="line">		if(elements.length &#x3D;&#x3D; size) &#123;</span><br><span class="line">			elements &#x3D; Arrays.copyOf(elements, 2 * size + 1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的 pop 方法却存在内存泄露的问题，当我们用 pop 方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引 用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发 Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成 OutOfMemoryError。</p>
<h2 id="26、抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被-synchronized修饰？"><a href="#26、抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被-synchronized修饰？" class="headerlink" title="26、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被 synchronized修饰？"></a>26、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被 synchronized修饰？</h2><p>都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如 C 代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized 和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</p>
<h2 id="27、阐述静态变量和实例变量的区别。"><a href="#27、阐述静态变量和实例变量的区别。" class="headerlink" title="27、阐述静态变量和实例变量的区别。"></a>27、阐述静态变量和实例变量的区别。</h2><p>静态变量是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。</p>
<p>补充：在 Java 开发中，上下文类和工具类中通常会有大量的静态成员。</p>
<h2 id="28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><a href="#28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？" class="headerlink" title="28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"></a>28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</h2><p>不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。</p>
<h2 id="29、如何实现对象克隆？"><a href="#29、如何实现对象克隆？" class="headerlink" title="29、如何实现对象克隆？"></a>29、如何实现对象克隆？</h2><p>有两种方式：</p>
<p>1). 实现 Cloneable 接口并重写 Object 类中的 clone()方法；</p>
<p>2). 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">public class MyUtil &#123;</span><br><span class="line">	private MyUtil() &#123;</span><br><span class="line">		throw new AssertionError();</span><br><span class="line">	&#125;</span><br><span class="line">	@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">	public static &lt;T extends Serializable&gt; T clone(T obj) throws</span><br><span class="line">	Exception &#123;</span><br><span class="line">		ByteArrayOutputStream bout &#x3D; new ByteArrayOutputStream();</span><br><span class="line">		ObjectOutputStream oos &#x3D; new ObjectOutputStream(bout);</span><br><span class="line">		oos.writeObject(obj);</span><br><span class="line">		ByteArrayInputStream bin &#x3D; new</span><br><span class="line">		ByteArrayInputStream(bout.toByteArray());</span><br><span class="line">		ObjectInputStream ois &#x3D; new ObjectInputStream(bin);</span><br><span class="line">		return (T) ois.readObject();</span><br><span class="line">		&#x2F;&#x2F; 说明：调用 ByteArrayInputStream 或 ByteArrayOutputStream</span><br><span class="line">		对象的 close 方法没有任何意义</span><br><span class="line">		&#x2F;&#x2F; 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这</span><br><span class="line">		一点不同于对外部资源（如文件流）的释放</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">import java.io.Serializable;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 人类</span><br><span class="line">* @author 骆昊</span><br><span class="line">*</span><br><span class="line">*&#x2F;</span><br><span class="line">class Person implements Serializable &#123;</span><br><span class="line">	private static final long serialVersionUID &#x3D; -9102017020286042305L;</span><br><span class="line">	private String name;</span><br><span class="line">	&#x2F;&#x2F; 姓名</span><br><span class="line">	private int age;</span><br><span class="line">	&#x2F;&#x2F; 年龄</span><br><span class="line">	private Car car;</span><br><span class="line">	&#x2F;&#x2F; 座驾</span><br><span class="line">	public Person(String name, int age, Car car) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.age &#x3D; age;</span><br><span class="line">		this.car &#x3D; car;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">	&#125;</span><br><span class="line">	public int getAge() &#123;</span><br><span class="line">		return age;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setAge(int age) &#123;</span><br><span class="line">		this.age &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line">	public Car getCar() &#123;</span><br><span class="line">		return car;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setCar(Car car) &#123;</span><br><span class="line">		this.car &#x3D; car;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;Person [name&#x3D;&quot; + name + &quot;, age&#x3D;&quot; + age + &quot;, car&#x3D;&quot; +</span><br><span class="line">		car + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 小汽车类</span><br><span class="line">* @author 骆昊</span><br><span class="line">*</span><br><span class="line">*&#x2F;</span><br><span class="line">class Car implements Serializable &#123;</span><br><span class="line">	private static final long serialVersionUID &#x3D; -5713945027627603702L;</span><br><span class="line">	private String brand;</span><br><span class="line">	&#x2F;&#x2F; 品牌</span><br><span class="line">	private int maxSpeed;</span><br><span class="line">	&#x2F;&#x2F; 最高时速</span><br><span class="line">	public Car(String brand, int maxSpeed) &#123;</span><br><span class="line">		this.brand &#x3D; brand;</span><br><span class="line">		this.maxSpeed &#x3D; maxSpeed;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getBrand() &#123;</span><br><span class="line">		return brand;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setBrand(String brand) &#123;</span><br><span class="line">		this.brand &#x3D; brand;</span><br><span class="line">	&#125;</span><br><span class="line">	public int getMaxSpeed() &#123;</span><br><span class="line">		return maxSpeed;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setMaxSpeed(int maxSpeed) &#123;</span><br><span class="line">		this.maxSpeed &#x3D; maxSpeed;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;Car [brand&#x3D;&quot; + brand + &quot;, maxSpeed&#x3D;&quot; + maxSpeed +</span><br><span class="line">		&quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class CloneTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			Person p1 &#x3D; new Person(&quot;Hao LUO&quot;, 33, new Car(&quot;Benz&quot;,</span><br><span class="line">			300));</span><br><span class="line">			Person p2 &#x3D; MyUtil.clone(p1);</span><br><span class="line">			&#x2F;&#x2F; 深度克隆</span><br><span class="line">			p2.getCar().setBrand(&quot;BYD&quot;);</span><br><span class="line">			&#x2F;&#x2F; 修改克隆的 Person 对象 p2 关联的汽车对象的品牌属性</span><br><span class="line">			&#x2F;&#x2F; 原来的 Person 对象 p1 关联的汽车不会受到任何影响</span><br><span class="line">			&#x2F;&#x2F; 因为在克隆 Person 对象时其关联的汽车对象也被克隆了</span><br><span class="line">			System.out.println(p1);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用 Object 类的 clone 方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。</p>
<h2 id="30、GC-是什么？为什么要有-GC？"><a href="#30、GC-是什么？为什么要有-GC？" class="headerlink" title="30、GC 是什么？为什么要有 GC？"></a>30、GC 是什么？为什么要有 GC？</h2><p>GC 是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但 JVM 可以屏蔽掉显示的垃圾回收调用。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在 Java 诞生初期，垃圾回收是 Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今 Java 的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得 iOS 的系统比 Android 系统有更好的用户体验，其中一个深层次的原因就在于 Android 系统中垃圾回收的不可预知性。</p>
<p>补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的 Java 进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java 平台对堆内存回收和再利用的基本算法被称为标记和清除，但是 Java 对其进行了改进，采用“分代式垃圾收集”。这种方法会跟 Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域：</p>
<p>（1）伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。</p>
<p>（2）幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。</p>
<p>（3）终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。</p>
<p>与垃圾回收相关的 JVM 参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-Xms &#x2F; -Xmx — 堆的初始大小 &#x2F; 堆的最大大小</span><br><span class="line"> -Xmn — 堆中年轻代的大小</span><br><span class="line"> -XX:-DisableExplicitGC — 让 System.gc()不产生任何作用</span><br><span class="line"> -XX:+PrintGCDetails — 打印 GC 的细节</span><br><span class="line"> -XX:+PrintGCDateStamps — 打印 GC 操作的时间戳</span><br><span class="line"> -XX:NewSize &#x2F; XX:MaxNewSize — 设置新生代大小&#x2F;新生代最大大小</span><br><span class="line"> -XX:NewRatio — 可以设置老生代和新生代的比例</span><br><span class="line"> -XX:PrintTenuringDistribution — 设置每次新生代 GC 后输出幸存者</span><br><span class="line">乐园中对象年龄的分布</span><br><span class="line"> -XX:InitialTenuringThreshold &#x2F; -XX:MaxTenuringThreshold：设置老</span><br><span class="line">年代阀值的初始值和最大值</span><br><span class="line"> -XX:TargetSurvivorRatio：设置幸存区的目标使用率</span><br></pre></td></tr></table></figure>

<h2 id="31、String-s-new-String-“xyz”-创建了几个字符串对象？"><a href="#31、String-s-new-String-“xyz”-创建了几个字符串对象？" class="headerlink" title="31、String s = new String(“xyz”);创建了几个字符串对象？"></a>31、String s = new String(“xyz”);创建了几个字符串对象？</h2><p>两个对象，一个是静态区的”xyz”，一个是用 new 创建在堆上的对象。</p>
<h2 id="32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concreteclass）？"><a href="#32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concreteclass）？" class="headerlink" title="32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concreteclass）？"></a>32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concreteclass）？</h2><p>接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。</p>
<h2 id="33、一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><a href="#33、一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？" class="headerlink" title="33、一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"></a>33、一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</h2><p>可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。</p>
<h2 id="34、Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？"><a href="#34、Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？" class="headerlink" title="34、Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？"></a>34、Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</h2><p>可以继承其他类或实现其他接口，在 Swing 编程和 Android 开发中常用此方式来实现事件监听和回调。</p>
<h2 id="35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><a href="#35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"></a>35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</h2><p>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</p>
<h2 id="36、Java-中的-final-关键字有哪些用法？"><a href="#36、Java-中的-final-关键字有哪些用法？" class="headerlink" title="36、Java 中的 final 关键字有哪些用法？"></a>36、Java 中的 final 关键字有哪些用法？</h2><p>(1)修饰类：表示该类不能被继承；</p>
<p>(2)修饰方法：表示方法不能被重写； </p>
<p>(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。</p>
<h2 id="37、指出下面程序的运行结果"><a href="#37、指出下面程序的运行结果" class="headerlink" title="37、指出下面程序的运行结果"></a>37、指出下面程序的运行结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">	static &#123;</span><br><span class="line">		System.out.print(&quot;1&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public A() &#123;</span><br><span class="line">		System.out.print(&quot;2&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">	static &#123;</span><br><span class="line">		System.out.print(&quot;a&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public B() &#123;</span><br><span class="line">		System.out.print(&quot;b&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Hello &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		A ab &#x3D; new B();</span><br><span class="line">		ab &#x3D; new B();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行结果：</strong>1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。</p>
<p><strong>提示：</strong>如果不能给出此题的正确答案，说明之前第 21 题 Java 类加载机制还没有完全理解，赶紧再看看吧。</p>
<h2 id="38、数据类型之间的转换："><a href="#38、数据类型之间的转换：" class="headerlink" title="38、数据类型之间的转换："></a>38、数据类型之间的转换：</h2><p>（1） 如何将字符串转换为基本数据类型？</p>
<p>（2） 如何将基本数据类型转换为字符串？</p>
<p>答：</p>
<p>（1）调用基本数据类型对应的包装类中的方法 parseXXX(String)或valueOf(String)即可返回相应基本类型；</p>
<p>（2）一种方法是将基本数据类型与空字符串（”“）连接（+）即可获得其所对应的字符串；另一种方法是调用 String 类中的 valueOf()方法返回相应字符串</p>
<h2 id="39、如何实现字符串的反转及替换？"><a href="#39、如何实现字符串的反转及替换？" class="headerlink" title="39、如何实现字符串的反转及替换？"></a>39、如何实现字符串的反转及替换？</h2><p>方法很多，可以自己写实现也可以使用 String 或 StringBuffer/StringBuilder 中的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static String reverse(String originStr) &#123;</span><br><span class="line">	if(originStr &#x3D;&#x3D; null || originStr.length() &lt;&#x3D; 1)</span><br><span class="line">	return originStr;</span><br><span class="line">	return reverse(originStr.substring(1)) + originStr.charAt(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="40、怎样将-GB2312-编码的字符串转换为-ISO-8859-1-编码的字符串？"><a href="#40、怎样将-GB2312-编码的字符串转换为-ISO-8859-1-编码的字符串？" class="headerlink" title="40、怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串？"></a>40、怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串？</h2><p>代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 &#x3D; &quot;你好&quot;;</span><br><span class="line">String s2 &#x3D; new String(s1.getBytes(&quot;GB2312&quot;), &quot;ISO-8859-1&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="41、日期和时间："><a href="#41、日期和时间：" class="headerlink" title="41、日期和时间："></a>41、日期和时间：</h2><p>（1）如何取得年月日、小时分钟秒？</p>
<p>（2） 如何取得从 1970 年 1 月 1 日 0 时 0 分 0 秒到现在的毫秒数？</p>
<p>（3） 如何取得某月的最后一天？</p>
<p>（4）如何格式化日期？</p>
<p>答：</p>
<p><strong>问题 1：</strong>创建 java.util.Calendar 实例，调用其 get()方法传入不同的参数即可获得参数所对应的值。Java 8 中可以使用 java.time.LocalDateTimel 来获取，代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class DateTimeTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Calendar cal &#x3D; Calendar.getInstance();</span><br><span class="line">		System.out.println(cal.get(Calendar.YEAR));</span><br><span class="line">		System.out.println(cal.get(Calendar.MONTH));</span><br><span class="line">		&#x2F;&#x2F; 0 - 11</span><br><span class="line">		System.out.println(cal.get(Calendar.DATE));</span><br><span class="line">		System.out.println(cal.get(Calendar.HOUR_OF_DAY));</span><br><span class="line">		System.out.println(cal.get(Calendar.MINUTE));</span><br><span class="line">		System.out.println(cal.get(Calendar.SECOND));</span><br><span class="line">		&#x2F;&#x2F; Java 8</span><br><span class="line">		LocalDateTime dt &#x3D; LocalDateTime.now();</span><br><span class="line">		System.out.println(dt.getYear());</span><br><span class="line">		System.out.println(dt.getMonthValue());</span><br><span class="line">		&#x2F;&#x2F; 1 - 12</span><br><span class="line">		System.out.println(dt.getDayOfMonth());</span><br><span class="line">		System.out.println(dt.getHour());</span><br><span class="line">		System.out.println(dt.getMinute());</span><br><span class="line">		System.out.println(dt.getSecond());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题 2：</strong>以下方法均可获得该毫秒数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Calendar.getInstance().getTimeInMillis();</span><br><span class="line">System.currentTimeMillis();</span><br><span class="line">Clock.systemDefaultZone().millis();</span><br><span class="line">&#x2F;&#x2F; Java 8</span><br></pre></td></tr></table></figure>

<p><strong>问题 3：</strong>代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Calendar time &#x3D; Calendar.getInstance();</span><br><span class="line">time.getActualMaximum(Calendar.DAY_OF_MONTH</span><br></pre></td></tr></table></figure>

<p><strong>问题 4：</strong>利用 java.text.DataFormat 的子类（如 SimpleDateFormat 类）中的format(Date)方法可将日期格式化。Java 8 中可以用java.time.format.DateTimeFormatter 来格式化时间日期，代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.time.LocalDate;</span><br><span class="line">import java.time.format.DateTimeFormatter;</span><br><span class="line">import java.util.Date;</span><br><span class="line">class DateFormatTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SimpleDateFormat oldFormatter &#x3D; new</span><br><span class="line">		SimpleDateFormat(&quot;yyyy&#x2F;MM&#x2F;dd&quot;);</span><br><span class="line">		Date date1 &#x3D; new Date();</span><br><span class="line">		System.out.println(oldFormatter.format(date1));</span><br><span class="line">		&#x2F;&#x2F; Java 8</span><br><span class="line">		DateTimeFormatter newFormatter &#x3D;</span><br><span class="line">		DateTimeFormatter.ofPattern(&quot;yyyy&#x2F;MM&#x2F;dd&quot;);</span><br><span class="line">		LocalDate date2 &#x3D; LocalDate.now();</span><br><span class="line">		System.out.println(date2.format(newFormatter));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充：</strong>Java 的时间日期 API 一直以来都是被诟病的东西，为了解决这一问题，Java8 中引入了新的时间日期 API，其中包括 LocalDate、LocalTime、LocalDateTime、Clock、Instant 等类，这些的类的设计都使用了不变模式，因此是线程安全的设计。</p>
<h2 id="42、打印昨天的当前时刻。"><a href="#42、打印昨天的当前时刻。" class="headerlink" title="42、打印昨天的当前时刻。"></a>42、打印昨天的当前时刻。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Calendar;</span><br><span class="line">class YesterdayCurrent &#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Calendar cal &#x3D; Calendar.getInstance();</span><br><span class="line">		cal.add(Calendar.DATE, -1);</span><br><span class="line">		System.out.println(cal.getTime());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在 Java 8 中，可以用下面的代码实现相同的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.time.LocalDateTime;</span><br><span class="line">class YesterdayCurrent &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		LocalDateTime today &#x3D; LocalDateTime.now();</span><br><span class="line">		LocalDateTime yesterday &#x3D; today.minusDays(1);</span><br><span class="line">		System.out.println(yesterday);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="43、比较一下-Java-和-JavaSciprt。"><a href="#43、比较一下-Java-和-JavaSciprt。" class="headerlink" title="43、比较一下 Java 和 JavaSciprt。"></a>43、比较一下 Java 和 JavaSciprt。</h2><p>JavaScript 与 Java 是两个公司开发的不同的两个产品。Java 是原 SunMicrosystems 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而 JavaScript 是 Netscape 公司的产品，为了扩展 Netscape 浏览器的功能而开发的一种可以嵌入 Web 页面中运行的基于对象和事件驱动的解释性语言。JavaScript 的前身是 LiveScript；而 Java 的前身是 Oak 语言。</p>
<p>下面对两种语言间的异同作如下比较：</p>
<p>（1）基于对象和面向对象：Java 是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript 是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。</p>
<p>（2）解释和编译：Java 的源代码在执行之前，必须经过编译。JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了 JIT（即时编译）技术来提升 JavaScript 的运行效率）</p>
<p>（3）强类型变量和类型弱变量：Java 采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript 中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript 的解释器在运行时检查推断其数据类型。</p>
<p>（4）代码格式不一样。</p>
<p>补充：上面列出的四点是网上流传的所谓的标准答案。其实 Java 和 JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在 Java 中类（class）是一等公民，而 JavaScript 中函数（function）是一等公民，因此 JavaScript 支持函数式编程，可以使用 Lambda函数和闭包（closure），当然 Java 8 也开始支持函数式编程，提供了对 Lambda表达式以及函数式接口的支持。对于这类问题，在面试的时候最好还是用自己的语言回答会更加靠谱，不要背网上所谓的标准答案。</p>
<h2 id="44、什么时候用断言（assert）？"><a href="#44、什么时候用断言（assert）？" class="headerlink" title="44、什么时候用断言（assert）？"></a>44、什么时候用断言（assert）？</h2><p>断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为 true；如果表达式的值为 false，那么系统会报告一个 AssertionError。断言的使用如下面的代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(a &gt; 0); &#x2F;&#x2F; throws an AssertionError if a &lt;&#x3D; 0</span><br></pre></td></tr></table></figure>

<p>断言可以有两种形式：</p>
<p>assert Expression1;</p>
<p>assert Expression1 : Expression2 ;</p>
<p>Expression1 应该总是产生一个布尔值。</p>
<p>Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。</p>
<p>要在运行时启用断言，可以在启动 JVM 时使用-enableassertions 或者-ea 标记。要在运行时选择禁用断言，可以在启动 JVM 时使用-da 或者-disableassertions标记。要在系统类中启用或禁用断言，可使用-esa 或-dsa 标记。还可以在包的基础上启用或者禁用断言。</p>
<p>注意：断言不应该以任何方式改变程序的状态。简单的说，如果希望在不满足某些条件时阻止代码的执行，就可以考虑用断言来阻止它。</p>
<h2 id="45、Error-和-Exception-有什么区别？"><a href="#45、Error-和-Exception-有什么区别？" class="headerlink" title="45、Error 和 Exception 有什么区别？"></a>45、Error 和 Exception 有什么区别？</h2><p>Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；</p>
<p>Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。</p>
<h2 id="46、try-里有一个-return-语句，那么紧跟在这个-try-后的finally-里的代码会不会被执行，什么时候被执行，在-return前还是后"><a href="#46、try-里有一个-return-语句，那么紧跟在这个-try-后的finally-里的代码会不会被执行，什么时候被执行，在-return前还是后" class="headerlink" title="46、try{}里有一个 return 语句，那么紧跟在这个 try 后的finally{}里的代码会不会被执行，什么时候被执行，在 return前还是后?"></a>46、try{}里有一个 return 语句，那么紧跟在这个 try 后的finally{}里的代码会不会被执行，什么时候被执行，在 return前还是后?</h2><p>会执行，在方法返回调用者前执行。</p>
<p><strong>注意：</strong>在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也可以通过提升编译器的语法检查级别来产生警告或错误，Eclipse 中可以在如图所示的地方进行设置，强烈建议将此项设置为编译错误。</p>
<h2 id="47、Java-语言如何进行异常处理，关键字：throws、throw、try、catch、finally-分别如何使用？"><a href="#47、Java-语言如何进行异常处理，关键字：throws、throw、try、catch、finally-分别如何使用？" class="headerlink" title="47、Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally 分别如何使用？"></a>47、Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally 分别如何使用？</h2><p>Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws 和 finally。一般情况下是用 try 来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try 用来指定一块预防所有异常的程序；catch 子句紧跟在 try 块后面，用来指定你想要捕获的异常的类型；throw 语句用来明确地抛出一个异常；throws 用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally 为确保一段代码不管发生什么异常状况都要被执行；try 语句可以嵌套，每当遇到一个 try 语句，异常的结构就会被放入异常栈中，直到所有的 try 语句都完成。如果下一级的try 语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的 try 语句或者最终将异常抛给 JVM。</p>
<h2 id="48、运行时异常与受检异常有何异同？"><a href="#48、运行时异常与受检异常有何异同？" class="headerlink" title="48、运行时异常与受检异常有何异同？"></a>48、运行时异常与受检异常有何异同？</h2><p>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java 编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在 Effective Java 中对异常的使用给出了以下指导原则：</p>
<p>（1）不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调用者为了正常的控制流而使用异常）</p>
<p>（2）对可以恢复的情况使用受检异常，对编程错误使用运行时异常</p>
<p>（3）避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）</p>
<p>（4）优先使用标准的异常</p>
<p>（5）每个方法抛出的异常都要有文档</p>
<p>（6）保持异常的原子性</p>
<p>（7）不要在 catch 中忽略掉捕获到的异常</p>
<h2 id="49、列出一些你常见的运行时异常？"><a href="#49、列出一些你常见的运行时异常？" class="headerlink" title="49、列出一些你常见的运行时异常？"></a>49、列出一些你常见的运行时异常？</h2><p>（1）ArithmeticException（算术异常）</p>
<p>（2） ClassCastException （类转换异常）</p>
<p>（3） IllegalArgumentException （非法参数异常）</p>
<p>（4） IndexOutOfBoundsException （下标越界异常）</p>
<p>（5） NullPointerException （空指针异常）</p>
<p>（6） SecurityException （安全异常）</p>
<h2 id="50、阐述-final、finally、finalize-的区别。"><a href="#50、阐述-final、finally、finalize-的区别。" class="headerlink" title="50、阐述 final、finally、finalize 的区别。"></a>50、阐述 final、finally、finalize 的区别。</h2><p>（1） final：修饰符（关键字）有三种用法：如果一个类被声明为 final，意味着它不能再派生出新的子类，即不能被继承，因此它和 abstract 是反义词。将变量声明为 final，可以保证它们在使用中不被改变，被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为 final 的方法也同样只能使用，不能在子类中被重写。</p>
<p>（2）finally：通常放在 try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要 JVM 不关闭都能执行，可以将释放外部资源的代码写在 finally 块中.</p>
<p>（3）finalize：Object 类中定义的方法，Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写 finalize()方法可以整理系统资源或者执行其他清理工作。</p>
<h2 id="51、类-ExampleA-继承-Exception，类-ExampleB-继承ExampleA。"><a href="#51、类-ExampleA-继承-Exception，类-ExampleB-继承ExampleA。" class="headerlink" title="51、类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。"></a>51、类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。</h2><p>有如下代码片断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	throw new ExampleB(&quot;b&quot;)</span><br><span class="line">&#125;</span><br><span class="line">catch（ExampleA e）&#123;</span><br><span class="line">	System.out.println(&quot;ExampleA&quot;);</span><br><span class="line">&#125;</span><br><span class="line">catch（Exception e）&#123;</span><br><span class="line">	System.out.println(&quot;Exception&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**请问执行此段代码的输出是什么？</p>
<p><strong>答：</strong></p>
<p>输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的 ExampleB 类型的异常）</p>
<p>面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Annoyance extends Exception &#123;</span><br><span class="line">&#125;</span><br><span class="line">class Sneeze extends Annoyance &#123;</span><br><span class="line">&#125;</span><br><span class="line">class Human &#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	throws Exception &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				throw new Sneeze();</span><br><span class="line">			&#125;</span><br><span class="line">			catch ( Annoyance a ) &#123;</span><br><span class="line">				System.out.println(&quot;Caught Annoyance&quot;);</span><br><span class="line">				throw a;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch ( Sneeze s ) &#123;</span><br><span class="line">			System.out.println(&quot;Caught Sneeze&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="52、List、Set、Map-是否继承自-Collection-接口？"><a href="#52、List、Set、Map-是否继承自-Collection-接口？" class="headerlink" title="52、List、Set、Map 是否继承自 Collection 接口？"></a>52、List、Set、Map 是否继承自 Collection 接口？</h2><p>List、Set 是 ，Map 不是。Map 是键值对映射容器，与 List 和 Set 有明显的区别，而 Set 存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。</p>
<h2 id="53、阐述-ArrayList、Vector、LinkedList-的存储性能和特性。"><a href="#53、阐述-ArrayList、Vector、LinkedList-的存储性能和特性。" class="headerlink" title="53、阐述 ArrayList、Vector、LinkedList 的存储性能和特性。"></a>53、阐述 ArrayList、Vector、LinkedList 的存储性能和特性。</h2><p>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 中的方法由于添加了 synchronized 修饰，因此 Vector 是线程安全的容器，但性能上较ArrayList 差，因此已经是 Java 中的遗留容器。LinkedList 使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector 属于遗留容器（Java 早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于 ArrayList 和 LinkedListed 都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。</p>
<p><strong>补充：</strong>遗留容器中的 Properties 类和 Stack 类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable 并将其两个泛型参数设置为 String 类型，但是 Java API 中的Properties 直接继承了 Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是 Has-A 关系而不是 Is-A 关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是 Has-A 关系（关联）或Use-A 关系（依赖）。同理，Stack 类继承 Vector 也是不正确的。Sun 公司的工程师们也会犯这种低级错误，让人唏嘘不已。</p>
<h2 id="54、Collection-和-Collections-的区别？"><a href="#54、Collection-和-Collections-的区别？" class="headerlink" title="54、Collection 和 Collections 的区别？"></a>54、Collection 和 Collections 的区别？</h2><p>Collection 是一个接口，它是 Set、List 等容器的父接口；Collections 是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。</p>
<h2 id="55、List、Map、Set-三个接口存取元素时，各有什么特点？"><a href="#55、List、Map、Set-三个接口存取元素时，各有什么特点？" class="headerlink" title="55、List、Map、Set 三个接口存取元素时，各有什么特点？"></a>55、List、Map、Set 三个接口存取元素时，各有什么特点？</h2><p>List 以特定索引来存取元素，可以有重复元素。Set 不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map 保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set 和 Map 容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为 O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</p>
<h2 id="56、TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？"><a href="#56、TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？" class="headerlink" title="56、TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？"></a>56、TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</h2><p>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。Collections 工具类的 sort 方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。</p>
<h2 id="57、Thread-类的-sleep-方法和对象的-wait-方法都可以让线程暂停执行，它们有什么区别"><a href="#57、Thread-类的-sleep-方法和对象的-wait-方法都可以让线程暂停执行，它们有什么区别" class="headerlink" title="57、Thread 类的 sleep()方法和对象的 wait()方法都可以让线程暂停执行，它们有什么区别?"></a>57、Thread 类的 sleep()方法和对象的 wait()方法都可以让线程暂停执行，它们有什么区别?</h2><p>sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第 66 题中的线程状态转换图）。wait()是 Object 类的方法，调用对象的 wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的 notify()方法（或 notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</p>
<p>补充：可能不少人对什么是进程，什么是线程还比较模糊，对于为什么需要多线程编程也不是特别理解。简单的说：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是 CPU 调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的 CPU 资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费 CPU 时间。时下很时髦的 Node.js就采用了单线程异步 I/O 的工作模式。</p>
<h2 id="58、线程的-sleep-方法和-yield-方法有什么区别？"><a href="#58、线程的-sleep-方法和-yield-方法有什么区别？" class="headerlink" title="58、线程的 sleep()方法和 yield()方法有什么区别？"></a>58、线程的 sleep()方法和 yield()方法有什么区别？</h2><p>（1） sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</p>
<p>（2） 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；</p>
<p>（3）sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；</p>
<p>（4）sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性。</p>
<h2 id="59、当一个线程进入一个对象的-synchronized-方法-A-之后，其它线程是否可进入此对象的-synchronized-方法-B？"><a href="#59、当一个线程进入一个对象的-synchronized-方法-A-之后，其它线程是否可进入此对象的-synchronized-方法-B？" class="headerlink" title="59、当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？"></a>59、当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？</h2><p>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</p>
<h2 id="60、请说出与线程同步以及线程调度相关的方法。"><a href="#60、请说出与线程同步以及线程调度相关的方法。" class="headerlink" title="60、请说出与线程同步以及线程调度相关的方法。"></a>60、请说出与线程同步以及线程调度相关的方法。</h2><p>（1） wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</p>
<p>（2）sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常；</p>
<p>（3）notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</p>
<p>（4）notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</p>
<p>补充：Java 5 通过 Lock 接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock 接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了 newCondition()方法来产生用于线程之间通信的 Condition 对象；此外，Java 5 还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用 Semaphore 对象的 acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用 Semaphore 对象的 release()方法）。</p>
<h2 id="61、编写多线程程序有几种实现方式？"><a href="#61、编写多线程程序有几种实现方式？" class="headerlink" title="61、编写多线程程序有几种实现方式？"></a>61、编写多线程程序有几种实现方式？</h2><p>Java 5 以前实现多线程有两种实现方法：一种是继承 Thread 类；另一种是实现Runnable 接口。两种方式都要通过重写 run()方法来定义线程的行为，推荐使用后者，因为 Java 中的继承是单继承，一个类有一个父类，如果继承了 Thread 类就无法再继承其他类了，显然使用 Runnable 接口更为灵活。</p>
<p>补充：Java 5 以后创建线程还有第三种方式：实现 Callable 接口，该接口中的 call方法可以在线程执行结束时产生一个返回值。</p>
<h2 id="62、synchronized-关键字的用法？"><a href="#62、synchronized-关键字的用法？" class="headerlink" title="62、synchronized 关键字的用法？"></a>62、synchronized 关键字的用法？</h2><p>synchronized 关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用 synchronized(对象) { … }定义同步代码块，或者在声明方法时将 synchronized 作为方法的修饰符。在第 60 题的例子中已经展示了synchronized 关键字的用法。</p>
<h2 id="63、举例说明同步和异步。"><a href="#63、举例说明同步和异步。" class="headerlink" title="63、举例说明同步和异步。"></a>63、举例说明同步和异步。</h2><p>如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。</p>
<h2 id="64、启动一个线程是调用-run-还是-start-方法？"><a href="#64、启动一个线程是调用-run-还是-start-方法？" class="headerlink" title="64、启动一个线程是调用 run()还是 start()方法？"></a>64、启动一个线程是调用 run()还是 start()方法？</h2><p>启动一个线程是调用 start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由 JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。</p>
<h2 id="65、什么是线程池（thread-pool）？"><a href="#65、什么是线程池（thread-pool）？" class="headerlink" title="65、什么是线程池（thread pool）？"></a>65、什么是线程池（thread pool）？</h2><p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。Java 5+中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：</p>
<p>（1）newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
<p>（2）newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p>
<p>（3） newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。</p>
<p>（4）newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
<p>（5）newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
<p>第 60 题的例子中演示了通过 Executors 工具类创建线程池并使用线程池执行线程的代码。如果希望在服务器上使用线程池，强烈建议使用 newFixedThreadPool方法来创建线程池，这样能获得更好的性能。</p>
<h2 id="66、线程的基本状态以及状态之间的关系？"><a href="#66、线程的基本状态以及状态之间的关系？" class="headerlink" title="66、线程的基本状态以及状态之间的关系？"></a>66、线程的基本状态以及状态之间的关系？</h2><p><img src="http://cdn.panyucable.cn/zysheep/16ee51ba254f46ef.jpg" alt=""></p>
<p>说明：其中 Running 表示运行状态，Runnable 表示就绪状态（万事俱备，只欠CPU），Blocked 表示阻塞状态，阻塞状态又有多种情况，可能是因为调用 wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了 sleep()方法或 join()方法等待休眠或其他线程结束，或是因为发生了 I/O 中断。</p>
<h2 id="67、简述-synchronized-和-java-util-concurrent-locks-Lock的异同？"><a href="#67、简述-synchronized-和-java-util-concurrent-locks-Lock的异同？" class="headerlink" title="67、简述 synchronized 和 java.util.concurrent.locks.Lock的异同？"></a>67、简述 synchronized 和 java.util.concurrent.locks.Lock的异同？</h2><p>Lock 是 Java 5 以后引入的新的 API，和关键字 synchronized 相比主要相同点：Lock 能完成 synchronized 所实现的所有功能；主要不同点：Lock 有比synchronized 更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized 会自动释放锁，而 Lock 一定要求程序员手工释放，并且最好在 finally 块中释放（这是释放外部资源的最好的地方）。</p>
<h2 id="68、Java-中如何实现序列化，有什么意义？"><a href="#68、Java-中如何实现序列化，有什么意义？" class="headerlink" title="68、Java 中如何实现序列化，有什么意义？"></a>68、Java 中如何实现序列化，有什么意义？</h2><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。要实现序列化，需要让一个类实现 Serializable 接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过 writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过 readObject 方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆（可以参考第 29 题）。</p>
<h2 id="69、Java-中有几种类型的流？"><a href="#69、Java-中有几种类型的流？" class="headerlink" title="69、Java 中有几种类型的流？"></a>69、Java 中有几种类型的流？</h2><p>字节流和字符流。字节流继承于 InputStream、OutputStream，字符流继承于Reader、Writer。在 java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。关于 Java 的 I/O 需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外 Java 中的流不同于 C#的是它只有一个维度一个方向。</p>
<h2 id="70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。"><a href="#70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。" class="headerlink" title="70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。"></a>70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。</h2><p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">public final class MyUtil &#123;</span><br><span class="line">	&#x2F;&#x2F; 工具类中的方法都是静态方式访问的因此将构造器私有不允许创建对象</span><br><span class="line">	(绝对好习惯)</span><br><span class="line">	private MyUtil() &#123;</span><br><span class="line">		throw new AssertionError();</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;**</span><br><span class="line">* 统计给定文件中给定字符串的出现次数</span><br><span class="line">*</span><br><span class="line">* @param filename 文件名</span><br><span class="line">* @param word 字符串</span><br><span class="line">* @return 字符串在文件中出现的次数</span><br><span class="line">*&#x2F;</span><br><span class="line">	public static int countWordInFile(String filename, String word) &#123;</span><br><span class="line">		int counter &#x3D; 0;</span><br><span class="line">		try (FileReader fr &#x3D; new FileReader(filename)) &#123;</span><br><span class="line">			try (BufferedReader br &#x3D; new BufferedReader(fr)) &#123;</span><br><span class="line">				String line &#x3D; null;</span><br><span class="line">				while ((line &#x3D; br.readLine()) !&#x3D; null) &#123;</span><br><span class="line">					int index &#x3D; -1;</span><br><span class="line">					while (line.length() &gt;&#x3D; word.length() &amp;&amp; (index &#x3D;</span><br><span class="line">					line.indexOf(word)) &gt;&#x3D; 0) &#123;</span><br><span class="line">						counter++;</span><br><span class="line">						line &#x3D; line.substring(index + word.length());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Exception ex) &#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		return counter;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="71、如何用-Java-代码列出一个目录下所有的文件？"><a href="#71、如何用-Java-代码列出一个目录下所有的文件？" class="headerlink" title="71、如何用 Java 代码列出一个目录下所有的文件？"></a>71、如何用 Java 代码列出一个目录下所有的文件？</h2><p>如果只要求列出当前文件夹下的文件，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">class Test12 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		File f &#x3D; new File(&quot;&#x2F;Users&#x2F;Hao&#x2F;Downloads&quot;);</span><br><span class="line">		for (File temp : f.listFiles()) &#123;</span><br><span class="line">			if(temp.isFile()) &#123;</span><br><span class="line">				System.out.println(temp.getName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要对文件夹继续展开，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">class Test12 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		showDirectory(new File(&quot;&#x2F;Users&#x2F;Hao&#x2F;Downloads&quot;));</span><br><span class="line">	&#125;</span><br><span class="line">	public static void showDirectory(File f) &#123;</span><br><span class="line">		_walkDirectory(f, 0);</span><br><span class="line">	&#125;</span><br><span class="line">	private static void _walkDirectory(File f, int level) &#123;</span><br><span class="line">		if(f.isDirectory()) &#123;</span><br><span class="line">			for (File temp : f.listFiles()) &#123;</span><br><span class="line">				_walkDirectory(temp, level + 1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; level - 1; i++) &#123;</span><br><span class="line">				System.out.print(&quot;t&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(f.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 7 中可以使用 NIO.2 的 API 来做同样的事情，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ShowFileTest &#123;</span><br><span class="line">	public static void main(String[] args) throws IOException &#123;</span><br><span class="line">		Path initPath &#x3D; Paths.get(&quot;&#x2F;Users&#x2F;Hao&#x2F;Downloads&quot;);</span><br><span class="line">		Files.walkFileTree(initPath, new SimpleFileVisitor&lt;Path&gt;() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public FileVisitResult visitFile(Path file, BasicFileAttributes</span><br><span class="line">			attrs)</span><br><span class="line">			throws IOException &#123;</span><br><span class="line">				System.out.println(file.getFileName().toString());</span><br><span class="line">				return FileVisitResult.CONTINUE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="72、用-Java-的套接字编程实现一个多线程的回显（echo）服务器。"><a href="#72、用-Java-的套接字编程实现一个多线程的回显（echo）服务器。" class="headerlink" title="72、用 Java 的套接字编程实现一个多线程的回显（echo）服务器。"></a>72、用 Java 的套接字编程实现一个多线程的回显（echo）服务器。</h2><h2 id="73、XML-文档定义有几种形式？它们之间有何本质区别？解析XML-文档有哪几种方式？"><a href="#73、XML-文档定义有几种形式？它们之间有何本质区别？解析XML-文档有哪几种方式？" class="headerlink" title="73、XML 文档定义有几种形式？它们之间有何本质区别？解析XML 文档有哪几种方式？"></a>73、XML 文档定义有几种形式？它们之间有何本质区别？解析XML 文档有哪几种方式？</h2><p>XML 文档定义分为 DTD 和 Schema 两种形式，二者都是对 XML 语法的约束，其本质区别在于 Schema 本身也是一个 XML 文件，可以被 XML 解析器解析，而且可以为 XML 承载的数据定义类型，约束能力较之 DTD 更强大。对 XML 的解析主要有 DOM（文档对象模型，Document Object Model）、SAX（Simple API forXML）和 StAX（Java 6 中引入的新的解析 XML 的方式，Streaming API for XML），其中 DOM 处理大型文件时其性能下降的非常厉害，这个问题是由 DOM 树结构占用的内存较多造成的，而且 DOM 解析方式必须在解析文件之前把整个文档装入内存，适合对 XML 的随机访问（典型的用空间换取时间的策略）；SAX 是事件驱动型的 XML 解析方式，它顺序读取 XML 文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过事件回调代码来处理 XML 文件，适合对 XML 的顺序访问；顾名思义，StAX 把重点放在流上，实际上 StAX 与其他解析方式的本质区别就在于应用程序能够把 XML 作为一个事件流来处理。将 XML 作为一组事件来处理的想法并不新颖（ SAX 就是这样做的），但不同之处在于 StAX 允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。</p>
<h2 id="74、你在项目中哪些地方用到了-XML？"><a href="#74、你在项目中哪些地方用到了-XML？" class="headerlink" title="74、你在项目中哪些地方用到了 XML？"></a>74、你在项目中哪些地方用到了 XML？</h2><p>XML 的主要作用有两个方面：数据交换和信息配置。在做数据交换时，XML 将数据用标签组装成起来，然后压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再从 XML 文件中还原相关信息进行处理，XML 曾经是异构系统间交换数据的事实标准，但此项功能几乎已经被被JSON（JavaScript Object Notation）取而代之。当然，目前很多软件仍然使用 XML 来存储配置信息，我们在很多项目中通常也会将作为配置信息的硬代码写在 XML 文件中，Java 的很多框架也是这么做的，而且这些框架都选择了 dom4j  作为处理 XML 的工具，因为 Sun 公司的官方API 实在不怎么好用。</p>
<p>补充：现在有很多时髦的软件（如 Sublime）已经开始将配置文件书写成 JSON格式，我们已经强烈的感受到 XML 的另一项功能也将逐渐被业界抛弃。</p>
<h2 id="75、阐述-JDBC-操作数据库的步骤。"><a href="#75、阐述-JDBC-操作数据库的步骤。" class="headerlink" title="75、阐述 JDBC 操作数据库的步骤。"></a>75、阐述 JDBC 操作数据库的步骤。</h2><p>下面的代码以连接本机的 Oracle 数据库为例，演示 JDBC 操作数据库的步骤。</p>
<p>（1） 加载驱动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);</span><br></pre></td></tr></table></figure>

<p>（2） 创建连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Connection con &#x3D;</span><br><span class="line">DriverManager.getConnection(&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;,</span><br><span class="line">&quot;scott&quot;, &quot;tiger&quot;);</span><br></pre></td></tr></table></figure>

<p>（3） 创建语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement ps &#x3D; con.prepareStatement(&quot;select * from emp</span><br><span class="line">where sal between ? and ?&quot;);</span><br><span class="line">ps.setint(1, 1000);</span><br><span class="line">ps.setint(2, 3000);</span><br></pre></td></tr></table></figure>

<p>（4）执行语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rs &#x3D; ps.executeQuery();</span><br></pre></td></tr></table></figure>

<p>（5）处理结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(rs.next()) &#123;</span><br><span class="line">	System.out.println(rs.getint(&quot;empno&quot;) + &quot; - &quot; +</span><br><span class="line">	rs.getString(&quot;ename&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（6） 关闭资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">finally &#123;</span><br><span class="line">	if(con !&#x3D; null) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			con.close();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong>关闭外部资源的顺序应该和打开的顺序相反，也就是说先关闭 ResultSet、再关闭 Statement、在关闭 Connection。上面的代码只关闭了 Connection（连接），虽然通常情况下在关闭连接时，连接上创建的语句和打开的游标也会关闭，但不能保证总是如此，因此应该按照刚才说的顺序分别关闭。此外，第一步加载驱动在 JDBC 4.0 中是可以省略的（自动从类路径中加载驱动），但是我们建议保留。</p>
<h2 id="76、Statement-和-PreparedStatement-有什么区别？哪个性能更好？"><a href="#76、Statement-和-PreparedStatement-有什么区别？哪个性能更好？" class="headerlink" title="76、Statement 和 PreparedStatement 有什么区别？哪个性能更好？"></a>76、Statement 和 PreparedStatement 有什么区别？哪个性能更好？</h2><p>与 Statement 相比，①PreparedStatement 接口代表预编译的语句，它主要的优势在于可以减少 SQL 的编译错误并增加 SQL 的安全性（减少 SQL 注射攻击的可能性）；②PreparedStatement 中的 SQL 语句是可以带参数的，避免了用字符串连接拼接 SQL 语句的麻烦和不安全；③当批量处理 SQL 或频繁执行相同的查询时，PreparedStatement 有明显的性能上的优势，由于数据库可以将编译优化后的SQL 语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。</p>
<p>补充：为了提供对存储过程的调用，JDBC API 中还提供了 CallableStatement 接口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的 SQL 语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。</p>
<h2 id="77、使用-JDBC-操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？"><a href="#77、使用-JDBC-操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？" class="headerlink" title="77、使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？"></a>77、使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？</h2><p>要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的 setFetchSize()方法指定每次抓取的记录数（典型的空间换时间策略）；要提升更新数据的性能可以使用 PreparedStatement 语句构建批处理，将若干 SQL 语句置于一个批处理中执行。</p>
<h2 id="78、在进行数据库编程时，连接池有什么作用？"><a href="#78、在进行数据库编程时，连接池有什么作用？" class="headerlink" title="78、在进行数据库编程时，连接池有什么作用？"></a>78、在进行数据库编程时，连接池有什么作用？</h2><p>由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行 TCP 的三次握手，释放连接需要进行 TCP 四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在Java 开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于 Java 的开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid 等。</p>
<p>补充：在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对于这个问题的讨论已经超出了这里要阐述的范围。</p>
<h2 id="79、什么是-DAO-模式？"><a href="#79、什么是-DAO-模式？" class="headerlink" title="79、什么是 DAO 模式？"></a>79、什么是 DAO 模式？</h2><p>DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共 API 中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO 模式实际上包含了两个模式，一是 DataAccessor（数据访问器），二是 Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。</p>
<h2 id="80、事务的-ACID-是指什么？"><a href="#80、事务的-ACID-是指什么？" class="headerlink" title="80、事务的 ACID 是指什么？"></a>80、事务的 ACID 是指什么？</h2><p>（1）原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败；</p>
<p>（2）一致性(Consistent)：事务结束后系统状态是一致的；</p>
<p>（3）隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态；</p>
<p>（4）持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。</p>
<p><strong>补充：</strong>关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。首先需要知道的是，只有存在并发数据访问时才需要事务。当多个事务访问同一数据时，可能会存在 5 类问题，包括 3 类数据读取问题（脏读、不可重复读和幻读）和 2 类数据更新问题（第 1 类丢失更新和第 2 类丢失更新）。</p>
<p><strong>脏读（Dirty Read）：</strong>A 事务读取 B 事务尚未提交的数据并在此基础上操作，而 B事务执行回滚，那么 A 读取到的数据就是脏数据。</p>
<p><img src="http://cdn.panyucable.cn/zysheep/16ee51ba24693a35.jpg" alt=""></p>
<p><strong>不可重复读（Unrepeatable Read）：</strong>事务 A 重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务 B 修改过了。</p>
<p><img src="http://cdn.panyucable.cn/zysheep/16ee51ba264f6a29.jpg" alt=""></p>
<p><strong>幻读（Phantom Read）：</strong>事务 A 重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了被事务 B 提交的行。</p>
<p>第 1 类丢失更新：事务 A 撤销时，把已经提交的事务 B 的更新数据覆盖了。</p>
<p><img src="http://cdn.panyucable.cn/zysheep/16ee51ba2471a40a.jpg" alt=""></p>
<p>第 2 类丢失更新：事务 A 覆盖事务 B 已经提交的数据，造成事务 B 所做的操作丢失。</p>
<p><img src="http://cdn.panyucable.cn/zysheep/16ee51ba288a2776.jpg" alt=""></p>
<p>数据并发访问所产生的问题，在有些场景下可能是允许的，但是有些场景下可能就是致命的，数据库通常会通过锁机制来解决数据并发访问问题，按锁定对象不同可以分为表级锁和行级锁；按并发事务锁定关系可以分为共享锁和独占锁，具体的内容大家可以自行查阅资料进行了解。直接使用锁是非常麻烦的，为此数据库为用户提供了自动锁机制，只要用户指定会话的事务隔离级别，数据库就会通过分析 SQL 语句然后为事务访问的资源加上合适的锁，此外，数据库还会维护这些锁通过各种手段提高系统的性能，这些对用户来说都是透明的（就是说你不用理解，事实上我确实也不知道）。ANSI/ISOSQL 92 标准定义了 4 个等级的事务隔离级别，如下表所示：</p>
<p><img src="http://cdn.panyucable.cn/zysheep/16ee51ba4191cec9.jpg" alt=""></p>
<p>需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。</p>
<h2 id="81、JDBC-中如何进行事务处理？"><a href="#81、JDBC-中如何进行事务处理？" class="headerlink" title="81、JDBC 中如何进行事务处理？"></a>81、JDBC 中如何进行事务处理？</h2><p>Connection 提供了事务处理的方法，通过调用 setAutoCommit(false)可以设置手动提交事务；当事务完成后用 commit()显式提交事务；如果在事务处理过程中发生异常则通过 rollback()进行事务回滚。除此之外，从 JDBC 3.0 中还引入了Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。</p>
<h2 id="82、JDBC-能否处理-Blob-和-Clob？"><a href="#82、JDBC-能否处理-Blob-和-Clob？" class="headerlink" title="82、JDBC 能否处理 Blob 和 Clob？"></a>82、JDBC 能否处理 Blob 和 Clob？</h2><p>Blob 是指二进制大对象（Binary Large Object），而 Clob 是指大字符对象（Character Large Objec），因此其中 Blob 是为存储大的二进制数据而设计的，而 Clob 是为存储大的文本数据而设计的。JDBC 的 PreparedStatement 和ResultSet 都提供了相应的方法来支持 Blob 和 Clob 操作。</p>
<h2 id="83、简述正则表达式及其用途。"><a href="#83、简述正则表达式及其用途。" class="headerlink" title="83、简述正则表达式及其用途。"></a>83、简述正则表达式及其用途。</h2><p>在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p>
<p>说明：计算机诞生初期处理的信息几乎都是数值，但是时过境迁，今天我们使用计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支持。</p>
<h2 id="84、Java-中是如何支持正则表达式操作的？"><a href="#84、Java-中是如何支持正则表达式操作的？" class="headerlink" title="84、Java 中是如何支持正则表达式操作的？"></a>84、Java 中是如何支持正则表达式操作的？</h2><p>Java 中的 String 类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java 中可以用 Pattern 类表示正则表达式对象，它提供了丰富的 API 进行各种正则表达式操作。</p>
<p>面试题： - 如果要从字符串中截取第一个英文左括号之前的字符串，例如：北京市(朝阳区)(西城区)(海淀区)，截取结果为：北京市，那么正则表达式怎么写？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line">class RegExpTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String str &#x3D; &quot;北京市(朝阳区)(西城区)(海淀区)&quot;;</span><br><span class="line">		Pattern p &#x3D; Pattern.compile(&quot;.*?(?&#x3D;\()&quot;);</span><br><span class="line">		Matcher m &#x3D; p.matcher(str);</span><br><span class="line">		if(m.find()) &#123;</span><br><span class="line">			System.out.println(m.group());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="85、获得一个类的类对象有哪些方式？"><a href="#85、获得一个类的类对象有哪些方式？" class="headerlink" title="85、获得一个类的类对象有哪些方式？"></a>85、获得一个类的类对象有哪些方式？</h2><p>（1）方法 1：类型.class，例如：String.class</p>
<p>（2）方法 2：对象.getClass()，例如：”hello”.getClass()</p>
<p>（3）方法 3：Class.forName()，例如：Class.forName(“java.lang.String”)</p>
<h2 id="86、如何通过反射创建对象？"><a href="#86、如何通过反射创建对象？" class="headerlink" title="86、如何通过反射创建对象？"></a>86、如何通过反射创建对象？</h2><p>方法 1：通过类对象调用 newInstance()方法，例如：String.class.newInstance()</p>
<p>方法 2：通过类对象的 getConstructor()或 getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其 newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”);</p>
<h2 id="87、如何通过反射获取和设置对象私有字段的值？"><a href="#87、如何通过反射获取和设置对象私有字段的值？" class="headerlink" title="87、如何通过反射获取和设置对象私有字段的值？"></a>87、如何通过反射获取和设置对象私有字段的值？</h2><p>可以通过类对象的 getDeclaredField()方法字段（Field）对象，然后再通过字段对象的 setAccessible(true)将其设置为可以访问，接下来就可以通过 get/set 方法来获取/设置字段的值了。下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段的值，字段可以是基本类型也可以是对象类型且支持多级对象操作。</p>
<h2 id="88、如何通过反射调用对象的方法？"><a href="#88、如何通过反射调用对象的方法？" class="headerlink" title="88、如何通过反射调用对象的方法？"></a>88、如何通过反射调用对象的方法？</h2><p>请看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line">class MethodInvokeTest &#123;</span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		String str &#x3D; &quot;hello&quot;;</span><br><span class="line">		Method m &#x3D; str.getClass().getMethod(&quot;toUpperCase&quot;);</span><br><span class="line">		System.out.println(m.invoke(str));</span><br><span class="line">		&#x2F;&#x2F; HELLO</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="89、简述一下面向对象的”六原则一法则”。"><a href="#89、简述一下面向对象的”六原则一法则”。" class="headerlink" title="89、简述一下面向对象的”六原则一法则”。"></a>89、简述一下面向对象的”六原则一法则”。</h2><p>（1）单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，就如同葵花宝典或辟邪剑谱的中心思想就八个字”欲练此功必先自宫”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫”因为专注，所以专业”，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）</p>
<p>（2）开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）</p>
<p>（3）依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）</p>
<p>（4）里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov 女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）</p>
<p>（5）接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java 中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）</p>
<p>（6）合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A 关系、Has-A 关系、Use-A 关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A 关系，合成聚合复用原则想表达的是优先考虑 Has-A 关系而不是 Is-A 关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java 的 API 中也有不少滥用继承的例子，例如 Properties 类继承了 Hashtable类，Stack 类继承了 Vector 类，这些继承明显就是错误的，更好的做法是在Properties 类中放置一个 Hashtable 类型的成员并且将其键和值都设置为字符串来存储数据，而 Stack 类的设计也应该是在 Stack 类中放一个 Vector 对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）</p>
<p>（7）迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。（迪米特法则简单的说就是如何做到”低耦合”，门面模式和调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web 开发中作为前端控制器的 Servlet 或 Filter 不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。）</p>
<p><img src="http://cdn.panyucable.cn/zysheep/16ee51ba45cdd65f.jpg" alt=""></p>
<p><img src="http://cdn.panyucable.cn/zysheep/16ee51ba49e95b37.jpg" alt=""></p>
<h2 id="90、简述一下你了解的设计模式。"><a href="#90、简述一下你了解的设计模式。" class="headerlink" title="90、简述一下你了解的设计模式。"></a>90、简述一下你了解的设计模式。</h2><p>所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。</p>
<p>在 GoF 的《Design Patterns: Elements of Reusable Object-OrientedSoftware》中给出了三类（创建型[对类的实例化过程的抽象化]、结构型[描述如何将类或对象结合在一起形成更大的结构]、行为型[对在不同的对象之间划分责任和算法的抽象化]）共 23 种设计模式，包括：Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态 模式 ），Strategy（策略 模式 ），Template Method（模板方法模式），Chain Of Responsibility（责任链模式）。</p>
<p>面试被问到关于设计模式的知识时，可以拣最常用的作答，例如：</p>
<p>（1）工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。</p>
<p>（2）代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache 代理、防火墙代理、同步化代理、智能引用代理。</p>
<p>（3）适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。</p>
<p>（4）模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。除此之外，还可以讲讲上面提到的门面模式、桥梁模式、单例模式、装潢模式（Collections 工具类和 I/O 系统中都使用装潢模式）等，反正基本原则就是拣自己最熟悉的、用得最多的作答，以免言多必失。</p>
<h2 id="91、用-Java-写一个单例类。"><a href="#91、用-Java-写一个单例类。" class="headerlink" title="91、用 Java 写一个单例类。"></a>91、用 Java 写一个单例类。</h2><p>（1）饿汉式单例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">	private Singleton()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	private static Singleton instance &#x3D; new Singleton();</span><br><span class="line">	public static Singleton getInstance()&#123;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）懒汉式单例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">	private static Singleton instance &#x3D; null;</span><br><span class="line">	private Singleton() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	public static synchronized Singleton getInstance()&#123;</span><br><span class="line">		if (instance &#x3D;&#x3D; null) instance ＝ new Singleton();</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：实现一个单例有两点注意事项，①将构造器私有，不允许外界通过构造器创建对象；②通过公开的静态方法向外界返回类的唯一实例。这里有一个问题可以思考：Spring 的 IoC 容器可以为普通的类创建单例，它是怎么做到的呢？</p>
<h2 id="92、什么是-UML？"><a href="#92、什么是-UML？" class="headerlink" title="92、什么是 UML？"></a>92、什么是 UML？</h2><p>UML 是统一建模语言（Unified Modeling Language）的缩写，它发表于 1997年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用 UML 可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为。</p>
<h2 id="93、UML-中有哪些常用的图？"><a href="#93、UML-中有哪些常用的图？" class="headerlink" title="93、UML 中有哪些常用的图？"></a>93、UML 中有哪些常用的图？</h2><p>UML 定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequencediagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deploymentdiagram）等。在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。用例图：</p>
<p>类图：</p>
<p><img src="http://cdn.panyucable.cn/zysheep/16ee51ba494153a6.jpg" alt=""></p>
<p>时序图：</p>
<p><img src="http://cdn.panyucable.cn/zysheep/16ee51ba4c86a645.jpg" alt=""></p>
<h2 id="94、用-Java-写一个冒泡排序。"><a href="#94、用-Java-写一个冒泡排序。" class="headerlink" title="94、用 Java 写一个冒泡排序。"></a>94、用 Java 写一个冒泡排序。</h2><p>冒泡排序几乎是个程序员都写得出来，但是面试的时候如何写一个逼格高的冒泡排序却不是每个人都能做到，下面提供一个参考代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Comparator;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 排序器接口(策略模式: 将算法封装到具有共同接口的独立的类中使得它们可</span><br><span class="line">以相互替换)</span><br><span class="line">* @author 骆昊</span><br><span class="line">*</span><br><span class="line">*&#x2F;</span><br><span class="line">public interface Sorter &#123;</span><br><span class="line">	&#x2F;**</span><br><span class="line">* 排序</span><br><span class="line">* @param list 待排序的数组</span><br><span class="line">*&#x2F;</span><br><span class="line">	public &lt;T extends Comparable&lt;T&gt;&gt; void sort(T[] list);</span><br><span class="line">	&#x2F;**</span><br><span class="line">* 排序</span><br><span class="line">* @param list 待排序的数组</span><br><span class="line">* @param comp 比较两个对象的比较器</span><br><span class="line">*&#x2F;</span><br><span class="line">	public &lt;T&gt; void sort(T[] list, Comparator&lt;T&gt; comp);</span><br><span class="line">&#125;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 冒泡排序</span><br><span class="line">*</span><br><span class="line">* @author 骆昊</span><br><span class="line">*</span><br><span class="line">*&#x2F;</span><br><span class="line">public class BubbleSorter implements Sorter &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public &lt;T extends Comparable&lt;T&gt;&gt; void sort(T[] list) &#123;</span><br><span class="line">		Boolean swapped &#x3D; true;</span><br><span class="line">		for (int i &#x3D; 1, len &#x3D; list.length; i &lt; len &amp;&amp; swapped; ++i) &#123;</span><br><span class="line">			swapped &#x3D; false;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; len - i; ++j) &#123;</span><br><span class="line">				if (list[j].compareTo(list[j + 1]) &gt; 0) &#123;</span><br><span class="line">					T temp &#x3D; list[j];</span><br><span class="line">					list[j] &#x3D; list[j + 1];</span><br><span class="line">					list[j + 1] &#x3D; temp;</span><br><span class="line">					swapped &#x3D; true;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public &lt;T&gt; void sort(T[] list, Comparator&lt;T&gt; comp) &#123;</span><br><span class="line">		Boolean swapped &#x3D; true;</span><br><span class="line">		for (int i &#x3D; 1, len &#x3D; list.length; i &lt; len &amp;&amp; swapped; ++i) &#123;</span><br><span class="line">			swapped &#x3D; false;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; len - i; ++j) &#123;</span><br><span class="line">				if (comp.compare(list[j], list[j + 1]) &gt; 0) &#123;</span><br><span class="line">					T temp &#x3D; list[j];</span><br><span class="line">					list[j] &#x3D; list[j + 1];</span><br><span class="line">					list[j + 1] &#x3D; temp;</span><br><span class="line">					swapped &#x3D; true;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="95、用-Java-写一个折半查找。"><a href="#95、用-Java-写一个折半查找。" class="headerlink" title="95、用 Java 写一个折半查找。"></a>95、用 Java 写一个折半查找。</h2><p>折半查找，也称二分查找、二分搜索，是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组已经为空，则表示找不到指定的元素。这种搜索算法每一次比较都使搜索范围缩小一半，其时间复杂度是 O(logN)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Comparator;</span><br><span class="line">public class MyUtil &#123;</span><br><span class="line">	public static &lt;T extends Comparable&lt;T&gt;&gt; int binarySearch(T[] x, T</span><br><span class="line">	key) &#123;</span><br><span class="line">		return binarySearch(x, 0, x.length- 1, key);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 使用循环实现的二分查找</span><br><span class="line">	public static &lt;T&gt; int binarySearch(T[] x, T key, Comparator&lt;T&gt; comp)</span><br><span class="line">	&#123;</span><br><span class="line">		int low &#x3D; 0;</span><br><span class="line">		int high &#x3D; x.length - 1;</span><br><span class="line">		while (low &lt;&#x3D; high) &#123;</span><br><span class="line">			int mid &#x3D; (low + high) &gt;&gt;&gt; 1;</span><br><span class="line">			int cmp &#x3D; comp.compare(x[mid], key);</span><br><span class="line">			if (cmp &lt; 0) &#123;</span><br><span class="line">				low&#x3D; mid + 1;</span><br><span class="line">			&#125; else if (cmp &gt; 0) &#123;</span><br><span class="line">				high&#x3D; mid - 1;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return mid;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 使用递归实现的二分查找</span><br><span class="line">	private static&lt;T extends Comparable&lt;T&gt;&gt; int binarySearch(T[] x, int</span><br><span class="line">	low, int high, T key) &#123;</span><br><span class="line">		if(low &lt;&#x3D; high) &#123;</span><br><span class="line">			int mid &#x3D; low + ((high -low) &gt;&gt; 1);</span><br><span class="line">			if(key.compareTo(x[mid])&#x3D;&#x3D; 0) &#123;</span><br><span class="line">				return mid;</span><br><span class="line">			&#125; else if(key.compareTo(x[mid])&lt; 0) &#123;</span><br><span class="line">				return binarySearch(x,low, mid - 1, key);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return binarySearch(x,mid + 1, high, key);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：上面的代码中给出了折半查找的两个版本，一个用递归实现，一个用循环实现。需要注意的是计算中间位置时不应该使用(high+ low) / 2 的方式，因为加法运算可能导致整数越界，这里应该使用以下三种方式之一：low + (high - low)/ 2 或 low + (high – low) &gt;&gt; 1 或(low + high) &gt;&gt;&gt; 1（&gt;&gt;&gt;是逻辑右移，是不带符号位的右移）</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">三月三</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zysheep.cn/2020/03/03/interview/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98(%E4%B8%80)/">https://zysheep.cn/2020/03/03/interview/Java基础面试题(一)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zysheep.cn" target="_blank">三月三</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/">面试宝典</a></div><div class="post_share"><div class="social-share" data-image="http://cdn.panyucable.cn/zysheep/wallhaven-n673pw.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="https://cdn.jsdelivr.net/gh/zysheep/picgo-imgs/imgwechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="https://cdn.jsdelivr.net/gh/zysheep/picgo-imgs/imgalipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/03/03/interview/kafka%E9%9D%A2%E8%AF%95%E9%A2%98/"><img class="prev_cover" src="http://cdn.panyucable.cn/zysheep/kafka-logo-wide.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">kafka面试题</div></div></a></div><div class="next-post pull_right"><a href="/2020/03/02/Spring/Spring%20Boot%202.2.2/SpringBoot%E5%85%A5%E9%97%A8/"><img class="next_cover" src="http://cdn.panyucable.cn/zysheep/spring-boot-project-logo2.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring Boot入门</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/03/03/interview/Dubbo面试题/" title="Dubbo面试题"><img class="relatedPosts_cover" src="http://cdn.panyucable.cn/zysheep/feature_maintenance.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-03</div><div class="relatedPosts_title">Dubbo面试题</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/03/interview/JVM与调优面试题/" title="JVM与调优面试题"><img class="relatedPosts_cover" src="http://cdn.panyucable.cn/zysheep/1536x1058.jfif"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-03</div><div class="relatedPosts_title">JVM与调优面试题</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/03/interview/ElasticSearch面试题/" title="ElasticSearch面试题"><img class="relatedPosts_cover" src="http://cdn.panyucable.cn/zysheep/es-1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-03</div><div class="relatedPosts_title">ElasticSearch面试题</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/03/interview/Java基础面试题(二)/" title="Java 面试题（二）"><img class="relatedPosts_cover" src="http://cdn.panyucable.cn/zysheep/1536x1058.jfif"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-03</div><div class="relatedPosts_title">Java 面试题（二）</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/03/interview/Java并发编程面试题/" title="Java并发编程"><img class="relatedPosts_cover" src="http://cdn.panyucable.cn/zysheep/2026x1136.jfif"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-03</div><div class="relatedPosts_title">Java并发编程</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/03/interview/Java微服务面试题/" title="微服务面试题"><img class="relatedPosts_cover" src="http://cdn.panyucable.cn/zysheep/1768x1179.jfif"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-03</div><div class="relatedPosts_title">微服务面试题</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '502b8308721b081071a5',
  clientSecret: '35220d15c7f8aaf585d6822cf5d49fedf5b602d6',
  repo: 'blog-comment',
  owner: 'zysheep',
  admin: ['zysheep'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  perPage: 10,
  distractionFreeMode: false,
  pagerDirection: 'last',
  createIssueManually: false,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" style="background-image: url(http://cdn.panyucable.cn/zysheep/1927x1080.jfif)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By 三月三</div><div class="footer_custom_text">生活不只是眼前的苟且,还有诗和远方</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/third-party/click_heart.js"></script><script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/js/hideCategory.min.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>